<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>创建虚拟机</title>
    <link href="/2020/06/27/%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <url>/2020/06/27/%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="1-自定义虚拟机设置"><a href="#1-自定义虚拟机设置" class="headerlink" title="1.自定义虚拟机设置"></a>1.自定义虚拟机设置</h2><p><img src="%E8%87%AA%E5%AE%9A%E4%B9%89.png" srcset="/img/loading.gif" alt="alt"></p><h2 id="2-虚拟机硬件兼容性"><a href="#2-虚拟机硬件兼容性" class="headerlink" title="2.虚拟机硬件兼容性"></a>2.虚拟机硬件兼容性</h2><p><img src="workStation15.png" srcset="/img/loading.gif" alt="alt"></p><h2 id="3-操作系统选择"><a href="#3-操作系统选择" class="headerlink" title="3.操作系统选择"></a>3.操作系统选择</h2><p><img src="%E7%A8%8D%E5%90%8E%E5%AE%89%E8%A3%85%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.png" srcset="/img/loading.gif" alt="alt"></p><h2 id="4-CentOS"><a href="#4-CentOS" class="headerlink" title="4.CentOS"></a>4.CentOS</h2><p><img src="cnetOS7.png" srcset="/img/loading.gif" alt="alt"></p><h2 id="5-虚拟机位置"><a href="#5-虚拟机位置" class="headerlink" title="5.虚拟机位置"></a>5.虚拟机位置</h2><p><img src="%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BD%8D%E7%BD%AE.png" srcset="/img/loading.gif" alt="alt"></p><h2 id="6-处理器配置"><a href="#6-处理器配置" class="headerlink" title="6.处理器配置"></a>6.处理器配置</h2><p><img src="%E5%A4%84%E7%90%86%E5%99%A8%E9%85%8D%E7%BD%AE.png" srcset="/img/loading.gif" alt="alt"></p><h2 id="7-内存配置"><a href="#7-内存配置" class="headerlink" title="7.内存配置"></a>7.内存配置</h2><p><img src="%E5%86%85%E5%AD%98%E9%85%8D%E7%BD%AE.png" srcset="/img/loading.gif" alt="alt"></p><h2 id="8-网络类型-png"><a href="#8-网络类型-png" class="headerlink" title="8.网络类型.png"></a>8.网络类型.png</h2><p><img src="%E7%BD%91%E7%BB%9C%E7%B1%BB%E5%9E%8B.png" srcset="/img/loading.gif" alt="alt"></p><h2 id="9-IO控制器类型"><a href="#9-IO控制器类型" class="headerlink" title="9.IO控制器类型"></a>9.IO控制器类型</h2><p><img src="io.png" srcset="/img/loading.gif" alt="alt"></p><h2 id="10-磁盘类型-png"><a href="#10-磁盘类型-png" class="headerlink" title="10.磁盘类型.png"></a>10.磁盘类型.png</h2><p><img src="%E7%A3%81%E7%9B%98%E7%B1%BB%E5%9E%8B.png" srcset="/img/loading.gif" alt="alt"></p><h2 id="11-磁盘使用-png"><a href="#11-磁盘使用-png" class="headerlink" title="11.磁盘使用.png"></a>11.磁盘使用.png</h2><p><img src="%E7%A3%81%E7%9B%98%E4%BD%BF%E7%94%A8.png" srcset="/img/loading.gif" alt="alt"></p><h2 id="12-磁盘大小"><a href="#12-磁盘大小" class="headerlink" title="12.磁盘大小"></a>12.磁盘大小</h2><p><img src="%E7%A3%81%E7%9B%98%E5%A4%A7%E5%B0%8F.png" srcset="/img/loading.gif" alt="alt"></p><h2 id="13-磁盘文件"><a href="#13-磁盘文件" class="headerlink" title="13.磁盘文件"></a>13.磁盘文件</h2><p><img src="%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6.png" srcset="/img/loading.gif" alt="alt"></p><h2 id="14-自定义硬件"><a href="#14-自定义硬件" class="headerlink" title="14.自定义硬件"></a>14.自定义硬件</h2><h3 id="移除打印机"><a href="#移除打印机" class="headerlink" title="移除打印机"></a>移除打印机</h3><p><img src="%E7%A7%BB%E9%99%A4%E6%89%93%E5%8D%B0%E6%9C%BA.png" srcset="/img/loading.gif" alt="alt"></p><h3 id="开启处理器虚拟化"><a href="#开启处理器虚拟化" class="headerlink" title="开启处理器虚拟化"></a>开启处理器虚拟化</h3><p><img src="%E5%A4%84%E7%90%86%E5%99%A8%E8%99%9A%E6%8B%9F%E5%8C%96.png" srcset="/img/loading.gif" alt="alt"></p><h3 id="设置操纵系统镜像"><a href="#设置操纵系统镜像" class="headerlink" title="设置操纵系统镜像"></a>设置操纵系统镜像</h3><p><img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%95%9C%E5%83%8F.png" srcset="/img/loading.gif" alt="alt"></p><h2 id="15-开启虚拟机，安装操作系统"><a href="#15-开启虚拟机，安装操作系统" class="headerlink" title="15.开启虚拟机，安装操作系统"></a>15.开启虚拟机，安装操作系统</h2><h2 id="16-语言选择"><a href="#16-语言选择" class="headerlink" title="16.语言选择"></a>16.语言选择</h2><p><img src="%E8%AF%AD%E8%A8%80%E9%80%89%E6%8B%A9.png" srcset="/img/loading.gif" alt="alt"></p><h2 id="17-选择安装的软件"><a href="#17-选择安装的软件" class="headerlink" title="17.选择安装的软件"></a>17.选择安装的软件</h2><p><img src="%E9%80%89%E6%8B%A9%E5%AE%89%E8%A3%85%E7%9A%84%E8%BD%AF%E4%BB%B6.png" srcset="/img/loading.gif" alt="alt"></p><h2 id="18-安装位置自定义分区"><a href="#18-安装位置自定义分区" class="headerlink" title="18.安装位置自定义分区"></a>18.安装位置自定义分区</h2><p><img src="%E5%AE%89%E8%A3%85%E4%BD%8D%E7%BD%AE%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%86%E5%8C%BA.png" srcset="/img/loading.gif" alt="alt"></p><h3 id="引导区配置"><a href="#引导区配置" class="headerlink" title="引导区配置"></a>引导区配置</h3><p><img src="%E5%BC%95%E5%AF%BC%E5%8C%BA.png" srcset="/img/loading.gif" alt="alt"></p><h3 id="交换区配置"><a href="#交换区配置" class="headerlink" title="交换区配置"></a>交换区配置</h3><p><img src="%E4%BA%A4%E6%8D%A2%E5%8C%BA%E9%85%8D%E7%BD%AE.png" srcset="/img/loading.gif" alt="alt"></p><h3 id="根分区配置"><a href="#根分区配置" class="headerlink" title="根分区配置"></a>根分区配置</h3><p><img src="%E6%A0%B9%E5%88%86%E5%8C%BA%E9%85%8D%E7%BD%AE.png" srcset="/img/loading.gif" alt="alt"></p><h2 id="19-网络主机名配置"><a href="#19-网络主机名配置" class="headerlink" title="19.网络主机名配置"></a>19.网络主机名配置</h2><h3 id="主机名配置"><a href="#主机名配置" class="headerlink" title="主机名配置"></a>主机名配置</h3><p><img src="%E4%B8%BB%E6%9C%BA%E5%90%8D%E9%85%8D%E7%BD%AE.png" srcset="/img/loading.gif" alt="alt"></p><h3 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h3><p><img src="%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE.png" srcset="/img/loading.gif" alt="alt"></p><h2 id="20-安装操作系统"><a href="#20-安装操作系统" class="headerlink" title="20.安装操作系统"></a>20.安装操作系统</h2><p><img src="%E5%AE%89%E8%A3%85%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.png" srcset="/img/loading.gif" alt="alt"></p><h2 id="21-关闭防火墙"><a href="#21-关闭防火墙" class="headerlink" title="21.关闭防火墙"></a>21.关闭防火墙</h2><pre><code class="hljs routeros">systemctl <span class="hljs-builtin-name">disable</span> firewalld</code></pre><h2 id="22-关闭SeLinux"><a href="#22-关闭SeLinux" class="headerlink" title="22.关闭SeLinux"></a>22.关闭SeLinux</h2><pre><code class="hljs arduino">vim etc/selinux/<span class="hljs-built_in">config</span></code></pre><p><img src="%E5%85%B3%E9%97%ADse.png" srcset="/img/loading.gif" alt="alt"></p><h2 id="23-重启操作系统"><a href="#23-重启操作系统" class="headerlink" title="23.重启操作系统"></a>23.重启操作系统</h2><pre><code class="hljs ebnf"><span class="hljs-attribute">reboot</span></code></pre><h2 id="修改ip"><a href="#修改ip" class="headerlink" title="修改ip"></a>修改ip</h2><pre><code class="hljs awk">vim  <span class="hljs-regexp">/etc/</span>sysconfig<span class="hljs-regexp">/network-scripts/i</span>fcfg-ens33</code></pre><p><img src="ip.png" srcset="/img/loading.gif" alt="alt"></p><h2 id="修改主机名"><a href="#修改主机名" class="headerlink" title="修改主机名"></a>修改主机名</h2><pre><code class="hljs vim"><span class="hljs-keyword">vim</span> /etc/<span class="hljs-built_in">hostname</span></code></pre><p><img src="hostname.png" srcset="/img/loading.gif" alt="alt"></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>enviroment</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三路快速排序算法</title>
    <link href="/2020/06/18/%E4%B8%89%E8%B7%AF%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2020/06/18/%E4%B8%89%E8%B7%AF%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs reasonml">package com.paulo.algorithm;import com.alibaba.fastjson.JSON;import org.apache.commons.lang3.ArrayUtils;import java.util.Random;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 三路快速排序</span><span class="hljs-comment"> * 等于的部分不进行排序</span><span class="hljs-comment"> */</span>public <span class="hljs-keyword">class</span> QuickSort3 &#123;    public static void main(String<span class="hljs-literal">[]</span> args) &#123;        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">9</span>,<span class="hljs-number">3</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>&#125;;        sort(arr,<span class="hljs-number">9</span>);        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JSON</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">JSONString(<span class="hljs-params">arr</span>)</span>);    &#125;    public static void sort(<span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> arr, <span class="hljs-built_in">int</span> n) &#123;        <span class="hljs-constructor">__sort(<span class="hljs-params">arr</span>,0,<span class="hljs-params">n</span>-1)</span>;    &#125;    <span class="hljs-keyword">private</span> static void <span class="hljs-constructor">__sort(<span class="hljs-params">int</span>[] <span class="hljs-params">arr</span>, <span class="hljs-params">int</span> <span class="hljs-params">l</span>, <span class="hljs-params">int</span> <span class="hljs-params">r</span>)</span> &#123;        <span class="hljs-keyword">if</span> (r - l &lt;= <span class="hljs-number">15</span>) &#123;            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">InsertSort</span>.</span></span>sort(arr, l, r);            return;        &#125;        Random random = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Random(System.<span class="hljs-params">currentTimeMillis</span>()</span>);        <span class="hljs-built_in">int</span> randomNum = random.next<span class="hljs-constructor">Int(<span class="hljs-params">r</span> - <span class="hljs-params">l</span> + 1)</span> + l;        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ArrayUtils</span>.</span></span>swap(arr, randomNum, l);        <span class="hljs-comment">//[l+1,lt] &lt; arr[l]; (lt,i) = arr[l]; [gt,r] &gt; arr[l]</span>        <span class="hljs-built_in">int</span> lt = l, gt = r + <span class="hljs-number">1</span>;        for (<span class="hljs-built_in">int</span> i = l + <span class="hljs-number">1</span>; i &lt; gt; i++) &#123;            <span class="hljs-keyword">if</span> (arr<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> &lt; arr<span class="hljs-literal">[<span class="hljs-identifier">l</span>]</span>) &#123;                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ArrayUtils</span>.</span></span>swap(arr, lt + <span class="hljs-number">1</span>, i);                lt++;                i++;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> &gt; arr<span class="hljs-literal">[<span class="hljs-identifier">l</span>]</span>) &#123;                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ArrayUtils</span>.</span></span>swap(arr, i, gt - <span class="hljs-number">1</span>);                gt--;            &#125; <span class="hljs-keyword">else</span> &#123;                i++;            &#125;        &#125;        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ArrayUtils</span>.</span></span>swap(arr, l, lt);        <span class="hljs-constructor">__sort(<span class="hljs-params">arr</span>, <span class="hljs-params">l</span>, <span class="hljs-params">lt</span> - 1)</span>;        <span class="hljs-constructor">__sort(<span class="hljs-params">arr</span>, <span class="hljs-params">gt</span>, <span class="hljs-params">r</span>)</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>basic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双路快速排序算法</title>
    <link href="/2020/06/18/%E5%8F%8C%E8%B7%AF%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2020/06/18/%E5%8F%8C%E8%B7%AF%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs reasonml">package com.paulo.algorithm;import com.alibaba.fastjson.JSON;import org.apache.commons.lang3.ArrayUtils;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 双路快速排序</span><span class="hljs-comment"> * 解决了大量重复数据的问题</span><span class="hljs-comment"> */</span>public <span class="hljs-keyword">class</span> QuickSort2 &#123;    public static void main(String<span class="hljs-literal">[]</span> args) &#123;        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">100</span>&#125;;        sort(arr,<span class="hljs-number">11</span>);        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JSON</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">JSONString(<span class="hljs-params">arr</span>)</span>);    &#125;    public static void sort(<span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> arr, <span class="hljs-built_in">int</span> n) &#123;        <span class="hljs-constructor">__sort(<span class="hljs-params">arr</span>,0,<span class="hljs-params">n</span>-1)</span>;    &#125;    <span class="hljs-keyword">private</span> static void <span class="hljs-constructor">__sort(<span class="hljs-params">int</span>[] <span class="hljs-params">arr</span>, <span class="hljs-params">int</span> <span class="hljs-params">l</span>, <span class="hljs-params">int</span> <span class="hljs-params">r</span>)</span> &#123;        <span class="hljs-keyword">if</span> (l &gt;= r) &#123;            return;        &#125;        <span class="hljs-built_in">int</span> p = <span class="hljs-constructor">__partition2(<span class="hljs-params">arr</span>, <span class="hljs-params">l</span>, <span class="hljs-params">r</span>)</span>;        <span class="hljs-constructor">__sort(<span class="hljs-params">arr</span>, <span class="hljs-params">l</span>, <span class="hljs-params">p</span> - 1)</span>;        <span class="hljs-constructor">__sort(<span class="hljs-params">arr</span>, <span class="hljs-params">p</span> + 1, <span class="hljs-params">r</span>)</span>;    &#125;    <span class="hljs-keyword">private</span> static <span class="hljs-built_in">int</span> <span class="hljs-constructor">__partition2(<span class="hljs-params">int</span>[] <span class="hljs-params">arr</span>, <span class="hljs-params">int</span> <span class="hljs-params">l</span>, <span class="hljs-params">int</span> <span class="hljs-params">r</span>)</span> &#123;        <span class="hljs-comment">//[l+1,i) &lt;= arr[l]   (j,r] &gt;= arr[l]</span>        <span class="hljs-built_in">int</span> i = l + <span class="hljs-number">1</span>, j = r;        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;            <span class="hljs-keyword">while</span> (i &lt; r<span class="hljs-operator"> &amp;&amp; </span>arr<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> &lt; arr<span class="hljs-literal">[<span class="hljs-identifier">l</span>]</span>) i++;            <span class="hljs-keyword">while</span> (j &gt; l + <span class="hljs-number">1</span><span class="hljs-operator"> &amp;&amp; </span>arr<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span> &gt; arr<span class="hljs-literal">[<span class="hljs-identifier">l</span>]</span>) j--;            <span class="hljs-keyword">if</span> (j &lt;= i) break;            <span class="hljs-comment">//在等于时依然交换，解决了数据的平衡问题</span>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ArrayUtils</span>.</span></span>swap(arr, i, j);            i++;            j--;        &#125;        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ArrayUtils</span>.</span></span>swap(arr, j, l);        return j;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>basic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速排序算法</title>
    <link href="/2020/06/18/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2020/06/18/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs reasonml">package com.paulo.algorithm;import com.alibaba.fastjson.JSON;import java.util.Random;import static org.apache.commons.lang3.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ArrayUtils</span>.</span></span>swap;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 单路快速排序，大部分情况下排序速度都很快</span><span class="hljs-comment"> * 缺点: 如果存在大量重复的元素(比如100w条数据中全都是1-10的数字)会导致每次递归一半数据很大一半数据很小</span><span class="hljs-comment"> */</span>public <span class="hljs-keyword">class</span> QuickSort &#123;    public static void main(String<span class="hljs-literal">[]</span> args) &#123;        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>&#125;;        sort(arr,<span class="hljs-number">9</span>);        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JSON</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">JSONString(<span class="hljs-params">arr</span>)</span>);    &#125;    public static void sort(<span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> arr, <span class="hljs-built_in">int</span> n) &#123;        <span class="hljs-constructor">__sort(<span class="hljs-params">arr</span>,0,<span class="hljs-params">n</span>-1)</span>;    &#125;    public static void <span class="hljs-constructor">__sort(<span class="hljs-params">int</span>[] <span class="hljs-params">arr</span>, <span class="hljs-params">int</span> <span class="hljs-params">l</span>, <span class="hljs-params">int</span> <span class="hljs-params">r</span>)</span> &#123;        <span class="hljs-keyword">if</span> (r - l &lt; <span class="hljs-number">15</span>) &#123;            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">InsertSort</span>.</span></span>sort(arr,l,r);            return;        &#125;        <span class="hljs-built_in">int</span> p = <span class="hljs-constructor">__partition(<span class="hljs-params">arr</span>, <span class="hljs-params">l</span>, <span class="hljs-params">r</span>)</span>;        <span class="hljs-constructor">__sort(<span class="hljs-params">arr</span>, <span class="hljs-params">l</span>, <span class="hljs-params">p</span> - 1)</span>;        <span class="hljs-constructor">__sort(<span class="hljs-params">arr</span>, <span class="hljs-params">p</span> + 1, <span class="hljs-params">r</span>)</span>;    &#125;    public static <span class="hljs-built_in">int</span> <span class="hljs-constructor">__partition(<span class="hljs-params">int</span>[] <span class="hljs-params">arr</span>, <span class="hljs-params">int</span> <span class="hljs-params">l</span>, <span class="hljs-params">int</span> <span class="hljs-params">r</span>)</span> &#123;        <span class="hljs-comment">//解决有序数组时</span>        Random random = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Random(System.<span class="hljs-params">currentTimeMillis</span>()</span>);        <span class="hljs-built_in">int</span> swapIndex = random.next<span class="hljs-constructor">Int(<span class="hljs-params">r</span> - <span class="hljs-params">l</span> + 1)</span> + l;        swap(arr,l,swapIndex);        <span class="hljs-built_in">int</span> j = l;        <span class="hljs-comment">//[l+1,j] &lt;= arr[l], [j+1,i) &gt; arr[l]</span>        for (<span class="hljs-built_in">int</span> i = l + <span class="hljs-number">1</span>; i &lt;= r; i++) &#123;            <span class="hljs-keyword">if</span>(arr<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> &lt; arr<span class="hljs-literal">[<span class="hljs-identifier">l</span>]</span>)&#123;                swap(arr,j+<span class="hljs-number">1</span>,i);                j++;            &#125;        &#125;        swap(arr,l,j);        return j;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>basic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最大堆</title>
    <link href="/2020/06/18/%E6%9C%80%E5%A4%A7%E5%A0%86/"/>
    <url>/2020/06/18/%E6%9C%80%E5%A4%A7%E5%A0%86/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs angelscript">package com.paulo.algorithm.heap;<span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<span class="hljs-keyword">import</span> org.apache.commons.lang3.ArrayUtils;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 最大堆</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">MaxHeap</span> &#123;    <span class="hljs-keyword">private</span> Integer[] data;    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> counter;    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> capacity;    <span class="hljs-keyword">public</span> MaxHeap(<span class="hljs-built_in">int</span> capacity) &#123;        data = new Integer[capacity + <span class="hljs-number">1</span>];        counter = <span class="hljs-number">0</span>;        <span class="hljs-keyword">this</span>.capacity = capacity;    &#125;    <span class="hljs-keyword">public</span> Integer[] getData() &#123;        <span class="hljs-keyword">return</span> data;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span>ean isEmpty()&#123;        <span class="hljs-keyword">return</span> counter == <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取最大值</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> Integer pop() &#123;        <span class="hljs-keyword">if</span> (counter &lt;= <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        &#125;        <span class="hljs-built_in">int</span> ret = data[<span class="hljs-number">1</span>];        data[<span class="hljs-number">1</span>] = <span class="hljs-literal">null</span>;        shiftDown();        counter--;        <span class="hljs-keyword">return</span> ret;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> shiftDown() &#123;        <span class="hljs-built_in">int</span> j = <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (j * <span class="hljs-number">2</span> &lt;= counter) &#123;            <span class="hljs-keyword">if</span> (j * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;= counter &amp;&amp; data[j * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] &gt; data[j * <span class="hljs-number">2</span>]) &#123;                ArrayUtils.swap(data,j,j*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>);                j = j*<span class="hljs-number">2</span> +<span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                ArrayUtils.swap(data,j,j*<span class="hljs-number">2</span>);                j *= <span class="hljs-number">2</span>;            &#125;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 添加数据</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> insert(<span class="hljs-built_in">int</span> item) &#123;        <span class="hljs-keyword">if</span> (counter + <span class="hljs-number">1</span> &gt; capacity) &#123;            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"heap is full"</span>);            <span class="hljs-keyword">return</span>;        &#125;        data[counter + <span class="hljs-number">1</span>] = item;        counter++;        shiftUp(counter);    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> shiftUp(<span class="hljs-built_in">int</span> i) &#123;        <span class="hljs-built_in">int</span> aux = data[i];        <span class="hljs-built_in">int</span> j = i;        <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">1</span> &amp;&amp; data[j / <span class="hljs-number">2</span>] &lt; aux) &#123;            data[j] = data[j / <span class="hljs-number">2</span>];            j /= <span class="hljs-number">2</span>;        &#125;        data[j] = aux;    &#125;    <span class="hljs-keyword">public</span> static <span class="hljs-built_in">void</span> main(String[] args) &#123;        MaxHeap heap = new MaxHeap(<span class="hljs-number">10</span>);        heap.insert(<span class="hljs-number">1</span>);        heap.insert(<span class="hljs-number">10</span>);        heap.insert(<span class="hljs-number">2</span>);        heap.insert(<span class="hljs-number">12</span>);        <span class="hljs-keyword">while</span>(! heap.isEmpty())&#123;            System.<span class="hljs-keyword">out</span>.println(heap.pop());        &#125;        System.<span class="hljs-keyword">out</span>.println(JSON.toJSONString(heap.getData()));    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>basic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性表结构的增删查</title>
    <link href="/2020/05/31/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%BB%93%E6%9E%84%E7%9A%84%E5%A2%9E%E5%88%A0%E6%9F%A5/"/>
    <url>/2020/05/31/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%BB%93%E6%9E%84%E7%9A%84%E5%A2%9E%E5%88%A0%E6%9F%A5/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 单向链表</span><span class="hljs-comment"> */</span>public <span class="hljs-keyword">class</span> SingleLinkedList&lt;T&gt; &#123;    <span class="hljs-comment">//头结点</span>    <span class="hljs-keyword">private</span> Node&lt;T&gt; head = <span class="hljs-keyword">new</span> Node&lt;T&gt;(null);    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取头结点</span><span class="hljs-comment">     */</span>    public Node&lt;T&gt; get<span class="hljs-constructor">Head()</span> &#123;        return head;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 在链表最后添加节点</span><span class="hljs-comment">     */</span>    public void add(Node&lt;T&gt; node) &#123;        Node&lt;T&gt; aux = head;        <span class="hljs-keyword">while</span> (!<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Objects</span>.</span></span>is<span class="hljs-constructor">Null(<span class="hljs-params">aux</span>.<span class="hljs-params">getNext</span>()</span>)) &#123;            aux = aux.get<span class="hljs-constructor">Next()</span>;        &#125;        aux.set<span class="hljs-constructor">Next(<span class="hljs-params">node</span>)</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 删除节点</span><span class="hljs-comment">     */</span>    public void delete(T data) &#123;        Node&lt;T&gt; aux = head;        boolean isFind = <span class="hljs-literal">false</span>;        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;            <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Objects</span>.</span></span>is<span class="hljs-constructor">Null(<span class="hljs-params">head</span>.<span class="hljs-params">getNext</span>()</span>)) &#123;                break;            &#125;            <span class="hljs-keyword">if</span> (aux.get<span class="hljs-constructor">Next()</span>.get<span class="hljs-constructor">Data()</span>.equals(data)) &#123;                isFind = <span class="hljs-literal">true</span>;                break;            &#125;            aux = aux.get<span class="hljs-constructor">Next()</span>;        &#125;        <span class="hljs-keyword">if</span> (isFind) &#123;            aux.set<span class="hljs-constructor">Next(<span class="hljs-params">aux</span>.<span class="hljs-params">getNext</span>()</span>.get<span class="hljs-constructor">Next()</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">"删除的节点不存在"</span>);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 遍历链表</span><span class="hljs-comment">     */</span>    public void <span class="hljs-built_in">list</span><span class="hljs-literal">()</span> &#123;        Node&lt;T&gt; aux = head;        <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Objects</span>.</span></span>is<span class="hljs-constructor">Null(<span class="hljs-params">aux</span>.<span class="hljs-params">getNext</span>()</span>)) &#123;            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">"linked list is null."</span>);        &#125;        <span class="hljs-keyword">while</span> (!<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Objects</span>.</span></span>is<span class="hljs-constructor">Null(<span class="hljs-params">aux</span>.<span class="hljs-params">getNext</span>()</span>)) &#123;            aux = aux.get<span class="hljs-constructor">Next()</span>;            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JSON</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">JSONString(<span class="hljs-params">aux</span>)</span>);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 逆序链表</span><span class="hljs-comment">     */</span>    public void reverse<span class="hljs-literal">()</span> &#123;        <span class="hljs-comment">//指向前一个元素的指针</span>        Node&lt;T&gt; pre = null;        <span class="hljs-comment">//指向当前元素的指针</span>        Node&lt;T&gt; current = head.get<span class="hljs-constructor">Next()</span>;        <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Objects</span>.</span></span>is<span class="hljs-constructor">Null(<span class="hljs-params">current</span>.<span class="hljs-params">getNext</span>()</span>)) &#123;            return;        &#125;        <span class="hljs-keyword">while</span> (!<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Objects</span>.</span></span>is<span class="hljs-constructor">Null(<span class="hljs-params">current</span>)</span>) &#123;            <span class="hljs-comment">//指向下一个元素的指针</span>            Node&lt;T&gt; next = current.get<span class="hljs-constructor">Next()</span>;            current.set<span class="hljs-constructor">Next(<span class="hljs-params">pre</span>)</span>;            pre = current;            current = next;        &#125;        head.set<span class="hljs-constructor">Next(<span class="hljs-params">pre</span>)</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 查找链表中间元素的值</span><span class="hljs-comment">     */</span>    public T find<span class="hljs-constructor">Mid()</span>&#123;        Node&lt;T&gt; aux = head;        <span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Objects</span>.</span></span>is<span class="hljs-constructor">Null(<span class="hljs-params">aux</span>.<span class="hljs-params">getNext</span>()</span>))&#123;            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">"链表为空"</span>);        &#125;        <span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Objects</span>.</span></span>is<span class="hljs-constructor">Null(<span class="hljs-params">aux</span>.<span class="hljs-params">getNext</span>()</span>.get<span class="hljs-constructor">Next()</span>))&#123;            return aux.get<span class="hljs-constructor">Next()</span>.get<span class="hljs-constructor">Data()</span>;        &#125;        Node&lt;T&gt; next = aux.get<span class="hljs-constructor">Next()</span>;        Node&lt;T&gt; twoNext = aux.get<span class="hljs-constructor">Next()</span>;        <span class="hljs-keyword">while</span>(!<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Objects</span>.</span></span>is<span class="hljs-constructor">Null(<span class="hljs-params">twoNext</span>.<span class="hljs-params">getNext</span>()</span>)<span class="hljs-operator"> &amp;&amp; </span>!<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Objects</span>.</span></span>is<span class="hljs-constructor">Null(<span class="hljs-params">twoNext</span>.<span class="hljs-params">getNext</span>()</span>.get<span class="hljs-constructor">Next()</span>))&#123;            next = next.get<span class="hljs-constructor">Next()</span>;            twoNext = twoNext.get<span class="hljs-constructor">Next()</span>.get<span class="hljs-constructor">Next()</span>;        &#125;        return next.get<span class="hljs-constructor">Data()</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 判断是否是循环链表</span><span class="hljs-comment">     */</span>    public boolean is<span class="hljs-constructor">Column()</span>&#123;        Node&lt;T&gt; aux = head;        <span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Objects</span>.</span></span>is<span class="hljs-constructor">Null(<span class="hljs-params">aux</span>.<span class="hljs-params">getNext</span>()</span>))&#123;            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">"链表为空"</span>);        &#125;        <span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Objects</span>.</span></span>is<span class="hljs-constructor">Null(<span class="hljs-params">aux</span>.<span class="hljs-params">getNext</span>()</span>.get<span class="hljs-constructor">Next()</span>))&#123;            return <span class="hljs-literal">false</span>;        &#125;        Node&lt;T&gt; next = aux.get<span class="hljs-constructor">Next()</span>;        Node&lt;T&gt; twoNext = aux.get<span class="hljs-constructor">Next()</span>;        <span class="hljs-keyword">while</span>(!<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Objects</span>.</span></span>is<span class="hljs-constructor">Null(<span class="hljs-params">twoNext</span>.<span class="hljs-params">getNext</span>()</span>)<span class="hljs-operator"> &amp;&amp; </span>!<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Objects</span>.</span></span>is<span class="hljs-constructor">Null(<span class="hljs-params">twoNext</span>.<span class="hljs-params">getNext</span>()</span>.get<span class="hljs-constructor">Next()</span>))&#123;            next = next.get<span class="hljs-constructor">Next()</span>;            twoNext = twoNext.get<span class="hljs-constructor">Next()</span>.get<span class="hljs-constructor">Next()</span>;            <span class="hljs-keyword">if</span>(twoNext.get<span class="hljs-constructor">Data()</span>.equals(next.get<span class="hljs-constructor">Data()</span>))&#123;                return <span class="hljs-literal">true</span>;            &#125;        &#125;        return <span class="hljs-literal">false</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linkedList</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>归并排序算法</title>
    <link href="/2020/05/31/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2020/05/31/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs angelscript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 归并排序算法</span><span class="hljs-comment"> * 时间复杂度:O(NLogN)</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">MergerSort</span> &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 自顶向下的归并排序</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> static <span class="hljs-built_in">void</span> sort(<span class="hljs-built_in">int</span>[] arr, <span class="hljs-built_in">int</span> n) &#123;        __sort(arr, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 字底向上的归并排序，效率相比于自顶向下略低，但是不用数组索引操作元素，可以用来做链表排序</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> static <span class="hljs-built_in">void</span> sortBU(<span class="hljs-built_in">int</span>[] arr, <span class="hljs-built_in">int</span> n) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> sz = <span class="hljs-number">1</span>; sz &lt;= n; sz += sz) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-comment">/**i+sz&gt;=n表明只有左半部分*/</span> i + sz &lt; n; i += sz + sz) &#123;                __merge(arr, i, i + sz - <span class="hljs-number">1</span>, <span class="hljs-comment">/**右半部分的元素不足sz个时取所有的*/</span>Math.min(i + sz + sz - <span class="hljs-number">1</span>,n<span class="hljs-number">-1</span>));            &#125;        &#125;    &#125;    <span class="hljs-keyword">private</span> static <span class="hljs-built_in">void</span> __sort(<span class="hljs-built_in">int</span>[] arr, <span class="hljs-built_in">int</span> l, <span class="hljs-built_in">int</span> r) &#123;        <span class="hljs-keyword">if</span> (l &gt;= r) &#123;            <span class="hljs-comment">//优化2:在数组中元素个数很小的情况下，数组有序的可能性越大,在数组接近有序的情况下插入排序的时间复杂度接近O(N)</span>            <span class="hljs-comment">//在元素个数足够小的情况下O(NLogN)和O(NN^2)前面的N对排序的影响会更大，插入排序前面的系数较小</span>            InsertSort.sort(arr, l, r);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-built_in">int</span> mid = (l + r) / <span class="hljs-number">2</span>;        __sort(arr, l, mid);        __sort(arr, mid + <span class="hljs-number">1</span>, r);        <span class="hljs-comment">//优化1:如果左边的部分的最后一个元素&lt;=右边部分的第一个元素就不用再进行合并</span>        <span class="hljs-keyword">if</span> (arr[mid] &lt;= arr[mid + <span class="hljs-number">1</span>]) &#123;            <span class="hljs-keyword">return</span>;        &#125;        __merge(arr, l, mid, r);    &#125;    <span class="hljs-keyword">private</span> static <span class="hljs-built_in">void</span> __merge(<span class="hljs-built_in">int</span>[] arr, <span class="hljs-built_in">int</span> l, <span class="hljs-built_in">int</span> mid, <span class="hljs-built_in">int</span> r) &#123;        <span class="hljs-built_in">int</span>[] aux = new <span class="hljs-built_in">int</span>[r - l + <span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = l; i &lt;= r; i++) &#123;            aux[i - l] = arr[i];        &#125;        <span class="hljs-built_in">int</span> i = l, j = mid + <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> k = l; k &lt;= r; k++) &#123;            <span class="hljs-keyword">if</span> (i &gt; mid) &#123;                arr[k] = aux[j - l];                j++;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j &gt; r) &#123;                arr[k] = aux[i - l];                i++;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (aux[i - l] &gt; aux[j - l]) &#123;                arr[k] = aux[j - l];                j++;            &#125; <span class="hljs-keyword">else</span> &#123;                arr[k] = aux[i - l];                i++;            &#125;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>basic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>插入排序算法</title>
    <link href="/2020/05/31/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2020/05/31/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs angelscript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 插入排序算法</span><span class="hljs-comment"> * 时间复杂度:O(N^2)</span><span class="hljs-comment"> * 排序元素有序时时间复杂度退化成O(N),常用来做复杂排序算法中间部分排序的优化</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">InsertSort</span> &#123;    <span class="hljs-keyword">public</span> static <span class="hljs-built_in">void</span> sort(<span class="hljs-built_in">int</span>[] arr, <span class="hljs-built_in">int</span> n) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;            <span class="hljs-built_in">int</span> temp = arr[i];            <span class="hljs-built_in">int</span> j = i;            <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; temp &lt; arr[j - <span class="hljs-number">1</span>]) &#123;                arr[j] = arr[j - <span class="hljs-number">1</span>];                j--;            &#125;            arr[j] = temp;        &#125;    &#125;    <span class="hljs-keyword">public</span> static <span class="hljs-built_in">void</span> sort(<span class="hljs-built_in">int</span>[] arr, <span class="hljs-built_in">int</span> l, <span class="hljs-built_in">int</span> r) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = l + <span class="hljs-number">1</span>; i &lt;= r; i++) &#123;            <span class="hljs-built_in">int</span> temp = arr[i];            <span class="hljs-built_in">int</span> j = i;            <span class="hljs-keyword">while</span> (j &gt; l &amp;&amp; temp &lt; arr[j - <span class="hljs-number">1</span>]) &#123;                arr[j] = arr[j - <span class="hljs-number">1</span>];                j--;            &#125;            arr[j] = temp;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>basic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>选择排序算法</title>
    <link href="/2020/05/31/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2020/05/31/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs angelscript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 选择排序</span><span class="hljs-comment"> * 时间复杂度: O(N^2)</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">SelectSort</span> &#123;    <span class="hljs-keyword">public</span> static <span class="hljs-built_in">void</span> sort(<span class="hljs-built_in">int</span>[] arr, <span class="hljs-built_in">int</span> n) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;            <span class="hljs-built_in">int</span> minIndex = i;            <span class="hljs-built_in">int</span> minVal = arr[i];            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;                <span class="hljs-keyword">if</span>(arr[j] &lt; minVal)&#123;                    minIndex = j;                    minVal = arr[j];                &#125;            &#125;            <span class="hljs-keyword">if</span>(minIndex != i)&#123;                <span class="hljs-built_in">int</span> temp = arr[i];                arr[i] = minVal;                arr[minIndex] = temp;            &#125;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>basic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flink窗口的应用与实现</title>
    <link href="/2020/05/26/Flink%E7%AA%97%E5%8F%A3%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <url>/2020/05/26/Flink%E7%AA%97%E5%8F%A3%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="新事物的学习思路"><a href="#新事物的学习思路" class="headerlink" title="新事物的学习思路"></a>新事物的学习思路</h2><p><img src="learn.png" srcset="/img/loading.gif" alt="alt"></p><p>当我们碰到一项新的技术时，我们应该怎样去学习并应用它呢？在我个人看来，有这样一个学习的路径，应该把它拆成应用和实现两块。首先应该从它的应用入手，然后再深入它的实现。</p><p>应用主要分为三个部分，首先应该了解它的应用场景，比如窗口的一些使用场景。然后，进一步地我们去了解它的编程接口，最后再深入了解它的一些抽象概念。因为一个框架或一项技术，肯定有它的编程接口和抽象概念来组成它的编程模型。我们可以通过查看文档的方式来熟悉它的应用。在对应用这三个部分有了初步的了解后，我们就可以通过阅读代码的方式去了解它的一些实现了。</p><p>实现部分也分三个阶段，首先从工作流程开始，可以通过 API 层面不断的下钻来了解它的工作流程。接下来是它整体的设计模式，通常对一些框架来说，如果能构建一个比较成熟的生态，一定是在设计模式上有一些独特的地方，使其有一个比较好的扩展性。最后是它的数据结构和算法，因为为了能够处理海量数据并达到高性能，它的数据结构和算法一定有独到之处。我们可以做些深入了解。</p><p>以上大概是我们学习的一个路径。从实现的角度可以反哺到应用上来，通常在应用当中，刚接触某个概念的时候会有一些疑惑。当我们对实现有一些了解之后，应用中的这些疑惑就会迎刃而解。</p><h2 id="实时数仓的典型架构"><a href="#实时数仓的典型架构" class="headerlink" title="实时数仓的典型架构"></a>实时数仓的典型架构</h2><p><img src="%E5%AE%9E%E6%97%B6%E6%95%B0%E4%BB%93%E6%9E%B6%E6%9E%84.png" srcset="/img/loading.gif" alt="alt"></p><ul><li><p>第一种最简单的架构，ODS层的Kafka数据经过Flink的ETL处理之后写入DW层的Kafka，再通过Flink聚合写入ADS层的Mysql中做一个实时报表展现</p><p>  缺点: 由于MySql存储数据有限，所以聚合的时间粒度不能太细，维度组合不能太多</p></li><li><p>第二种架构相对于第一种引入了OLAP引擎，同时也不用Kafka来做聚合，通过Druid的Rollup来做聚合<br>  缺点: Druid是一个查询引擎，不是计算引擎。当数据量巨大时，每天上百亿、千亿的数据会加剧Druid的压力</p></li><li><p>第三种在第二种的基础上，采用Flink来聚合写入Kafka，最终写入Druid<br>  缺点: 当窗口粒度比较长，输出结果会有延迟</p></li><li><p>第四种在第三种的基础上，Flink做轻度的聚合，Druid的Rollup做汇总，Druid可以实时看到Flink聚合的结果</p></li></ul><h2 id="Flink-Window在实时数据处理中的应用场景"><a href="#Flink-Window在实时数据处理中的应用场景" class="headerlink" title="Flink Window在实时数据处理中的应用场景"></a>Flink Window在实时数据处理中的应用场景</h2><p><img src="window%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF.png" srcset="/img/loading.gif" alt="alt"></p><ul><li><p>聚合统计: 从Kafka读取数据，根据不同维度做1分钟或者5分钟聚合，然后将结果写入MySql或者Druid中</p></li><li><p>记录合并: 对多个Kafka数据源在一定的窗口范围内做合并，结果写入ES。例如：用户的一些行为数据，针对每个用户，可以对其行为做一定的合并，减少下游的数据量，降低ES的写入压力。</p></li><li><p>双流join: 针对双流join，如果全量join的话，内存开销会很大。所以考虑基于Window来做join</p></li></ul><h2 id="Window抽象概念"><a href="#Window抽象概念" class="headerlink" title="Window抽象概念"></a>Window抽象概念</h2><p><img src="Window%E6%8A%BD%E8%B1%A1%E6%A6%82%E5%BF%B5.png" srcset="/img/loading.gif" alt="alt"></p><ul><li><p>TimestampAssigner: 时间戳分配器，如果使用EventTime时间语义，需要TimestampAssigner告诉Flink框架元素的哪个字段是事件时间，用于后面的窗口计算</p></li><li><p>KeySelector：Key选择器，告诉Flink框架做聚合的维度</p></li><li><p>Window Assigner: 窗口分配器，将数据分配到相应的窗口</p></li><li><p>Window State: 存储窗口内的元素，如果有AggregateFunction存储的是增量聚合的结果</p></li><li><p>AggregateFunction(可选): 增量聚合函数，做窗口的增量计算，减轻State的存储压力</p></li><li><p>Trigger：触发器，确定窗口的触发时间</p></li><li><p>Evictor(可选): 驱逐器，在窗口函数之前或者之后对满足条件的数据过滤</p></li><li><p>WindowFunction: 窗口函数，对窗口内的数据进行计算</p></li><li><p>Collector: 收集器，将窗口的结果发送到下游</p></li></ul><h2 id="Window编程接口"><a href="#Window编程接口" class="headerlink" title="Window编程接口"></a>Window编程接口</h2><pre><code class="hljs clean">stream        .assignTimestampsAndWatermarks(…)     &lt;-    TimestampAssigner  .keyBy(...)                           &lt;-    KeySelector         .window(...)                          &lt;-    WindowAssigner          [.trigger(...)]                       &lt;-    Trigger           [.evictor(...)]                       &lt;-    Evictor  .reduce/aggregate/process()           &lt;-    Aggregate/Window function</code></pre><h3 id="Window-Assigner"><a href="#Window-Assigner" class="headerlink" title="Window Assigner"></a>Window Assigner</h3><p><img src="windowAssigner.png" srcset="/img/loading.gif" alt="alt"></p><p>主要有三种Window Assigner:</p><ul><li>Time Window</li><li>Count Window</li><li>Session Window</li></ul><h3 id="Window-Trigger"><a href="#Window-Trigger" class="headerlink" title="Window Trigger"></a>Window Trigger</h3><p>Trigger用来确定窗口合适触发，Flink内置了一些Trigger:</p><p><img src="trigger.png" srcset="/img/loading.gif" alt="alt"></p><h4 id="Trigger示例"><a href="#Trigger示例" class="headerlink" title="Trigger示例"></a>Trigger示例</h4><p><img src="continousEventTimeTrigger.png" srcset="/img/loading.gif" alt="alt"></p><p>假如我们定义一个5分钟的基于 EventTime 的滚动窗口，定义一个每2分触发计算的 Trigger，有4条数据事件时间分别是20:01、20:02、20:03、20:04，对应的值分别是1、2、3、2，我们要对值做 Sum 操作。</p><p>初始时，State 和 Result 中的值都为0。</p><p><img src="continousEventTimeTrigger1.png" srcset="/img/loading.gif" alt="alt"><br>当第一条数据在20:01进入窗口时，State 的值为1，此时还没有到达 Trigger 的触发时间。</p><p><img src="continousEventTimeTrigger2.png" srcset="/img/loading.gif" alt="alt"><br>第二条数据在20:02进入窗口，State 中的值为1+2=3，此时达到2分钟满足 Trigger 的触发条件，所以 Result 输出结果为3。</p><p><img src="continousEventTimeTrigger3.png" srcset="/img/loading.gif" alt="alt"><br>第三条数据在20:03进入窗口，State 中的值为3+3 = 6，此时未达到 Trigger 触发条件，没有结果输出。</p><p><img src="continousEventTimeTrigger4.png" srcset="/img/loading.gif" alt="alt"></p><p>第四条数据在20:04进入窗口，State中的值更新为6+2=8，此时又到了2分钟达到了 Trigger 触发时间，所以输出结果为8。如果我们把结果输出到支持 update 的存储，比如 MySQL，那么结果值就由之前的3更新成了8。</p><h4 id="如果Result只能Append"><a href="#如果Result只能Append" class="headerlink" title="如果Result只能Append"></a>如果Result只能Append</h4><p><img src="append.png" srcset="/img/loading.gif" alt="alt"></p><p>如果 Result 不支持 update 操作，只能 append 的话，则会输出2条记录，在此基础上再做计算处理就会引起错误。</p><p>这样就需要 PurgingTrigger 来处理上面的问题。</p><h4 id="PurgingTrigger-的应用"><a href="#PurgingTrigger-的应用" class="headerlink" title="PurgingTrigger 的应用"></a>PurgingTrigger 的应用</h4><p><img src="purgingTrigger.png" srcset="/img/loading.gif" alt="alt"><br>和上面的示例一样，唯一的不同是在 ContinuousEventTimeTrigger 外面包装了一个 PurgingTrigger，其作用是在 ContinuousEventTimeTrigger 触发窗口计算之后将窗口的 State 中的数据清除。</p><p><img src="purgingTrigger2.png" srcset="/img/loading.gif" alt="alt"></p><p>前两条数据先后于20:01和20:02进入窗口，此时 State 中的值更新为3，同时到了Trigger的触发时间，输出结果为3。</p><p><img src="purgingTrigger3.png" srcset="/img/loading.gif" alt="alt"><br>由于 PurgingTrigger 的作用，State 中的数据会被清除。</p><p><img src="purgingTrigger4.png" srcset="/img/loading.gif" alt="alt"><br>当后两条数据进入窗口之后，State 重新从0开始累计并更新为5，输出结果为5。</p><p>由于结果输出是 append 模式，会输出3和5两条数据，然后再做 Sum 也能得到正确的结果。</p><p>上面就是 PurgingTrigger 的一个简单的示例，它还支持很多有趣的玩法。</p><h4 id="DeltaTrigger-的应用"><a href="#DeltaTrigger-的应用" class="headerlink" title="DeltaTrigger 的应用"></a>DeltaTrigger 的应用</h4><p>有这样一个车辆区间测试的需求，车辆每分钟上报当前位置与车速，每行进10公里，计算区间内最高车速。</p><p><img src="car.png" srcset="/img/loading.gif" alt="alt"></p><p>首先需要考虑的是如何来划分窗口，它不是一个时间的窗口，也不是一个基于数量的窗口。用传统的窗口实现比较困难，这种情况下我们考虑使用 DeltaTrigger 来实现。</p><p><img src="code.png" srcset="/img/loading.gif" alt="alt"></p><p>如何提取时间戳和生成水印，以及选择聚合维度就不赘述了。这个场景不是传统意义上的时间窗口或数量窗口，可以创建一个 GlobalWindow，所有数据都在一个窗口中，我们通过定义一个 DeltaTrigger，并设定一个阈值，这里是10000（米）。每个元素和上次触发计算的元素比较是否达到设定的阈值，这里比较的是每个元素上报的位置，如果达到了10000（米），那么当前元素和上一个触发计算的元素之间的所有元素落在同一个窗口里计算，然后可以通过 Max 聚合计算出最大的车速</p><h3 id="Window-Evictor"><a href="#Window-Evictor" class="headerlink" title="Window Evictor"></a>Window Evictor</h3><p><img src="evictor.png" srcset="/img/loading.gif" alt="alt"></p><h4 id="TimeEvictor-的应用"><a href="#TimeEvictor-的应用" class="headerlink" title="TimeEvictor 的应用"></a>TimeEvictor 的应用</h4><p>基于上面的区间测速的场景，每行进10公里，计算区间内最近15分钟最高车速。</p><p><img src="timeEvictor.png" srcset="/img/loading.gif" alt="alt"></p><p>实现上只是在前面基础上增加了 Evictor 的使用，过滤掉窗口最后15分钟之前的数据。</p><p><img src="code2.png" srcset="/img/loading.gif" alt="alt"></p><h3 id="Window-Function"><a href="#Window-Function" class="headerlink" title="Window Function"></a>Window Function</h3><p>Flink 内置的 WindowFunction 有两种类型，第一种是 AggregateFunction，它是高级别的抽象，主要用来做增量聚合，每来一条元素都做一次聚合，这样状态里只需要存最新的聚合值。</p><ul><li>优点: 增量聚合，实现简单。</li><li>缺点: 输出只有一个聚合值，使用场景比较局限。</li></ul><p>第二种是 ProcessWindowFunction，它是低级别的抽象用来做全量聚合，每来一条元素都存在状态里面，只有当窗口触发计算时才会调用这个函数。</p><ul><li>优点: 可以获取到窗口内所有数据的迭代器，实现起来比较灵活；可以获取到聚合的  Key 以及可以从上下文 Context 中获取窗口的相关信息。</li><li>缺点: 需要存储窗口内的全量数据，State 的压力较大</li></ul><p>同时我们可以把这两种方式结合起来使用，通过 AggregateFunction 做增量聚合，减少中间状态的压力。通过 ProcessWindowFunction 来输出我们想要的信息，比如聚合的 Key 以及窗口的信息。</p><pre><code class="hljs lasso">mappedSource.keyBy((KeySelector&lt;Tuple3&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Integer</span>, Long&gt;, <span class="hljs-built_in">String</span>&gt;) stringIntegerLongTuple3 -&gt; stringIntegerLongTuple3.f0).timeWindow(Time.seconds(<span class="hljs-number">10</span>))        .reduce(<span class="hljs-literal">new</span> ReduceFunction&lt;Tuple3&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Integer</span>, Long&gt;&gt;() &#123;            @Override            <span class="hljs-keyword">public</span> Tuple3&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Integer</span>, Long&gt; reduce(Tuple3&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Integer</span>, Long&gt; stringIntegerLongTuple3, Tuple3&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Integer</span>, Long&gt; t1) throws Exception &#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">new</span> Tuple3&lt;&gt;(stringIntegerLongTuple3.f0, stringIntegerLongTuple3.f1 + t1.f1, stringIntegerLongTuple3.f2 + t1.f2);            &#125;            <span class="hljs-comment">//reduce做完增量聚合后将结果传到ProcessWindowFunction操作状态数据或者窗口信息</span>        &#125;, <span class="hljs-literal">new</span> ProcessWindowFunction&lt;Tuple3&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Integer</span>, Long&gt;, <span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>, TimeWindow&gt;() &#123;            @Override            <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> process(<span class="hljs-built_in">String</span> key, Context context, Iterable&lt;Tuple3&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Integer</span>, Long&gt;&gt; iterable, Collector&lt;<span class="hljs-built_in">String</span>&gt; collector) throws Exception &#123;                <span class="hljs-comment">//当ReduceFunction对整体的窗口数据做完聚合后会将结果放入iterable中这里可以获取到</span>                Iterator&lt;Tuple3&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Integer</span>, Long&gt;&gt; iterator = iterable.iterator();                TimeWindow window = context.window();                long start = window.getStart();                long end = window.getEnd();                <span class="hljs-keyword">while</span>(iterator.hasNext())&#123;                    Tuple3&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Integer</span>, Long&gt; next = iterator.next();                    collector.collect(<span class="hljs-built_in">String</span>.format(<span class="hljs-string">"key:%s, window start:%s, window end:%s, name:%s, score:%s"</span>,key,start,end,next.f0,next.f1));                &#125;            &#125;        &#125;);</code></pre><h2 id="工作流程和实现机制"><a href="#工作流程和实现机制" class="headerlink" title="工作流程和实现机制"></a>工作流程和实现机制</h2><h3 id="Window-Operator工作流程"><a href="#Window-Operator工作流程" class="headerlink" title="Window Operator工作流程"></a>Window Operator工作流程</h3><pre><code class="hljs reasonml">public void process<span class="hljs-constructor">Element(StreamRecord&lt;IN&gt; <span class="hljs-params">element</span>)</span> throws Exception &#123;       <span class="hljs-comment">//1.获取元素的窗口</span>       final Collection&lt;W&gt; elementWindows = windowAssigner.assign<span class="hljs-constructor">Windows(<span class="hljs-params">element</span>.<span class="hljs-params">getValue</span>()</span>, element.get<span class="hljs-constructor">Timestamp()</span>, windowAssignerContext);       <span class="hljs-comment">//element不属于任何窗口</span>       boolean isSkippedElement = <span class="hljs-literal">true</span>;       <span class="hljs-comment">//2.获取element的key</span>       final K key = this.&lt;K&gt;get<span class="hljs-constructor">KeyedStateBackend()</span>.get<span class="hljs-constructor">CurrentKey()</span>;       for (W window : elementWindows) &#123;           <span class="hljs-comment">//3.丢弃已经late的window(window的清除时间小于当前watermark)</span>           <span class="hljs-keyword">if</span> (is<span class="hljs-constructor">WindowLate(<span class="hljs-params">window</span>)</span>) &#123;               continue;           &#125;           isSkippedElement = <span class="hljs-literal">false</span>;           windowState.set<span class="hljs-constructor">CurrentNamespace(<span class="hljs-params">window</span>)</span>;           <span class="hljs-comment">//4.将element放入window state</span>           windowState.add(element.get<span class="hljs-constructor">Value()</span>);           triggerContext.key = key;           triggerContext.window = window;           <span class="hljs-comment">//5.判断element是否触发trigger</span>           TriggerResult triggerResult = triggerContext.on<span class="hljs-constructor">Element(<span class="hljs-params">element</span>)</span>;           <span class="hljs-keyword">if</span> (triggerResult.is<span class="hljs-constructor">Fire()</span>) &#123;               ACC contents = windowState.get<span class="hljs-literal">()</span>;               <span class="hljs-keyword">if</span> (contents<span class="hljs-operator"> == </span>null) &#123;                   continue;               &#125;               <span class="hljs-comment">//6.获取window state，注入window function</span>               emit<span class="hljs-constructor">WindowContents(<span class="hljs-params">window</span>, <span class="hljs-params">contents</span>)</span>;           &#125;           <span class="hljs-keyword">if</span> (triggerResult.is<span class="hljs-constructor">Purge()</span>) &#123;               <span class="hljs-comment">//7.清除window state</span>               windowState.clear<span class="hljs-literal">()</span>;           &#125;           <span class="hljs-comment">//8.注册清除window的定时器，在window结束时清除</span>           register<span class="hljs-constructor">CleanupTimer(<span class="hljs-params">window</span>)</span>;       &#125;       <span class="hljs-comment">// side output input event if</span>       <span class="hljs-comment">// element not handled by any window</span>       <span class="hljs-comment">// late arriving tag has been set</span>       <span class="hljs-comment">// windowAssigner is event time and current timestamp + allowed lateness no less than element timestamp</span>       <span class="hljs-comment">//9.迟到的元素放入迟到的输出</span>       <span class="hljs-keyword">if</span> (isSkippedElement<span class="hljs-operator"> &amp;&amp; </span>is<span class="hljs-constructor">ElementLate(<span class="hljs-params">element</span>)</span>) &#123;           <span class="hljs-keyword">if</span> (lateDataOutputTag != null) &#123;               side<span class="hljs-constructor">Output(<span class="hljs-params">element</span>)</span>;           &#125; <span class="hljs-keyword">else</span> &#123;               this.numLateRecordsDropped.inc<span class="hljs-literal">()</span>;           &#125;       &#125;   &#125;</code></pre><h3 id="Window-State"><a href="#Window-State" class="headerlink" title="Window State"></a>Window State</h3><p>前面提到的增量聚合计算和全量聚合计算，这两个场景所应用的 State 是不一样的。</p><p>如果是全量聚合，元素会添加到 ListState 当中，当触发窗口计算时，再把 ListState 中所有元素传递给窗口函数。</p><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(V value)</span> </span>&#123;Preconditions.checkNotNull(value, <span class="hljs-string">"You cannot add null to a ListState."</span>);<span class="hljs-keyword">final</span> N <span class="hljs-keyword">namespace</span> = currentNamespace;<span class="hljs-keyword">final</span> StateTable&lt;K, N, List&lt;V&gt;&gt; <span class="hljs-built_in">map</span> = stateTable;List&lt;V&gt; <span class="hljs-built_in">list</span> = <span class="hljs-built_in">map</span>.<span class="hljs-built_in">get</span>(<span class="hljs-keyword">namespace</span>);<span class="hljs-keyword">if</span> (<span class="hljs-built_in">list</span> == null) &#123;<span class="hljs-built_in">list</span> = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(<span class="hljs-keyword">namespace</span>, <span class="hljs-built_in">list</span>);&#125;<span class="hljs-built_in">list</span>.add(value);&#125;</code></pre><p>如果是增量计算，使用的是 AggregatingState，每条元素进来会触发 AggregateTransformation 的计算。</p><pre><code class="hljs php">@Override<span class="hljs-keyword">public</span> void add(IN value) throws IOException &#123;<span class="hljs-keyword">final</span> N <span class="hljs-keyword">namespace</span> = <span class="hljs-title">currentNamespace</span>;<span class="hljs-keyword">if</span> (value == <span class="hljs-keyword">null</span>) &#123;clear();<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">try</span> &#123;stateTable.transform(<span class="hljs-keyword">namespace</span>, <span class="hljs-title">value</span>, <span class="hljs-title">aggregateTransformation</span>);&#125; <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">Exception</span> e) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">"Exception while applying AggregateFunction in aggregating state"</span>, e);&#125;&#125;</code></pre><p>看下 AggregateTransformation 的实现，它会调用我们定义的 AgregateFunction 中的 createAccumulator 方法和 add 方法并将 add 的结果返回，所以 State 中存储的就是 accumulator 的值，所以比较轻量级。</p><pre><code class="hljs angelscript">static <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">AggregateTransformation</span>&lt;<span class="hljs-symbol">IN, <span class="hljs-symbol">ACC</span>, <span class="hljs-symbol">OUT</span></span>&gt; <span class="hljs-symbol">implements</span> <span class="hljs-symbol">StateTransformationFunction</span>&lt;<span class="hljs-symbol">ACC, <span class="hljs-symbol">IN</span></span>&gt; &#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AggregateFunction&lt;IN, ACC, OUT&gt; aggFunction;AggregateTransformation(AggregateFunction&lt;IN, ACC, OUT&gt; aggFunction) &#123;<span class="hljs-keyword">this</span>.aggFunction = Preconditions.checkNotNull(aggFunction);&#125;@Override<span class="hljs-keyword">public</span> ACC apply(ACC accumulator, IN value) &#123;<span class="hljs-keyword">if</span> (accumulator == <span class="hljs-literal">null</span>) &#123;accumulator = aggFunction.createAccumulator();&#125;<span class="hljs-keyword">return</span> aggFunction.add(value, accumulator);&#125;&#125;</code></pre><h3 id="Window-Function-1"><a href="#Window-Function-1" class="headerlink" title="Window Function"></a>Window Function</h3><p>在触发窗口计算时会将窗口中的状态传递给 emitWindowContents 方法。这里会调用我们定义的窗口函数中的 process 方法，将当前的 Key、Window、上下文 Context、窗口的内容作为参数传给它。在此之前和之后会分别调用 evictBefore 和evictAfter 方法把一些元素过滤掉。最终会调用 windowState 的 clear 方法，再把过滤之后的记录存到 windowState 中去。从而达到 evictor 过滤元素的效果。</p><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> void emit<span class="hljs-constructor">WindowContents(W <span class="hljs-params">window</span>, Iterable&lt;StreamRecord&lt;IN&gt;&gt; <span class="hljs-params">contents</span>, ListState&lt;StreamRecord&lt;IN&gt;&gt; <span class="hljs-params">windowState</span>)</span> throws Exception &#123;timestampedCollector.set<span class="hljs-constructor">AbsoluteTimestamp(<span class="hljs-params">window</span>.<span class="hljs-params">maxTimestamp</span>()</span>);<span class="hljs-comment">// Work around type system restrictions...</span>FluentIterable&lt;TimestampedValue&lt;IN&gt;&gt; recordsWithTimestamp = FluentIterable.from(contents).transform(<span class="hljs-keyword">new</span> Function&lt;StreamRecord&lt;IN&gt;, TimestampedValue&lt;IN&gt;&gt;<span class="hljs-literal">()</span> &#123;@Overridepublic TimestampedValue&lt;IN&gt; apply(StreamRecord&lt;IN&gt; input) &#123;return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TimestampedValue</span>.</span></span>from(input);&#125;&#125;);evictorContext.evict<span class="hljs-constructor">Before(<span class="hljs-params">recordsWithTimestamp</span>, Iterables.<span class="hljs-params">size</span>(<span class="hljs-params">recordsWithTimestamp</span>)</span>);FluentIterable&lt;IN&gt; projectedContents = recordsWithTimestamp.transform(<span class="hljs-keyword">new</span> Function&lt;TimestampedValue&lt;IN&gt;, IN&gt;<span class="hljs-literal">()</span> &#123;@Overridepublic IN apply(TimestampedValue&lt;IN&gt; input) &#123;return input.get<span class="hljs-constructor">Value()</span>;&#125;&#125;);processContext.window = triggerContext.window;userFunction.process(triggerContext.key, triggerContext.window, processContext, projectedContents, timestampedCollector);evictorContext.evict<span class="hljs-constructor">After(<span class="hljs-params">recordsWithTimestamp</span>, Iterables.<span class="hljs-params">size</span>(<span class="hljs-params">recordsWithTimestamp</span>)</span>);<span class="hljs-comment">//work around to fix FLINK-4369, remove the evicted elements from the windowState.</span><span class="hljs-comment">//this is inefficient, but there is no other way to remove elements from ListState, which is an AppendingState.</span>windowState.clear<span class="hljs-literal">()</span>;for (TimestampedValue&lt;IN&gt; record : recordsWithTimestamp) &#123;windowState.add(record.get<span class="hljs-constructor">StreamRecord()</span>);&#125;&#125;</code></pre><h3 id="Window-Trigger-1"><a href="#Window-Trigger-1" class="headerlink" title="Window Trigger"></a>Window Trigger</h3><p>最后看下 Trigger 的实现原理。当我们有大量的 Key，同时每个 Key 又属于多个窗口时，我们如何有效的触发窗口的计算呢？</p><p>Flink 利用定时器来保证窗口的触发，通过优先级队列来存储定时器。队列头的定时器表示离当前时间最近的一个，如果当前定时器比队列头的定时器时间还要早，则取消掉队列头的定时器，把当前的时间注册进去</p><pre><code class="hljs reasonml">@Overridepublic TriggerResult on<span class="hljs-constructor">Element(Object <span class="hljs-params">element</span>, <span class="hljs-params">long</span> <span class="hljs-params">timestamp</span>, TimeWindow <span class="hljs-params">window</span>, TriggerContext <span class="hljs-params">ctx</span>)</span> throws Exception &#123;<span class="hljs-keyword">if</span> (window.max<span class="hljs-constructor">Timestamp()</span> &lt;= ctx.get<span class="hljs-constructor">CurrentWatermark()</span>) &#123;<span class="hljs-comment">// if the watermark is already past the window fire immediately</span>return TriggerResult.FIRE;&#125; <span class="hljs-keyword">else</span> &#123;ctx.register<span class="hljs-constructor">EventTimeTimer(<span class="hljs-params">window</span>.<span class="hljs-params">maxTimestamp</span>()</span>);return TriggerResult.CONTINUE;&#125;&#125;</code></pre><pre><code class="hljs cpp">@Override<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerEventTimeTimer</span><span class="hljs-params">(N <span class="hljs-keyword">namespace</span>, <span class="hljs-keyword">long</span> time)</span> </span>&#123;eventTimeTimersQueue.add(<span class="hljs-keyword">new</span> TimerHeapInternalTimer&lt;&gt;(time, (K) keyContext.getCurrentKey(), <span class="hljs-keyword">namespace</span>));&#125;</code></pre><pre><code class="hljs reasonml">public void on<span class="hljs-constructor">EventTime(InternalTimer&lt;K, W&gt; <span class="hljs-params">timer</span>)</span> throws Exception &#123;    triggerContext.key = timer.get<span class="hljs-constructor">Key()</span>;    triggerContext.window = timer.get<span class="hljs-constructor">Namespace()</span>;    evictorContext.key = timer.get<span class="hljs-constructor">Key()</span>;    evictorContext.window = timer.get<span class="hljs-constructor">Namespace()</span>;    TriggerResult triggerResult = triggerContext.on<span class="hljs-constructor">EventTime(<span class="hljs-params">timer</span>.<span class="hljs-params">getTimestamp</span>()</span>);    <span class="hljs-keyword">if</span> (triggerResult.is<span class="hljs-constructor">Fire()</span>) &#123;        Iterable&lt;StreamRecord&lt;IN&gt;&gt; contents = evictingWindowState.get<span class="hljs-literal">()</span>;        <span class="hljs-keyword">if</span> (contents != null) &#123;            emit<span class="hljs-constructor">WindowContents(<span class="hljs-params">triggerContext</span>.<span class="hljs-params">window</span>, <span class="hljs-params">contents</span>, <span class="hljs-params">evictingWindowState</span>)</span>;        &#125;    &#125;    <span class="hljs-keyword">if</span> (triggerResult.is<span class="hljs-constructor">Purge()</span>) &#123;        evictingWindowState.clear<span class="hljs-literal">()</span>;    &#125;    <span class="hljs-keyword">if</span> (windowAssigner.is<span class="hljs-constructor">EventTime()</span><span class="hljs-operator"> &amp;&amp; </span>is<span class="hljs-constructor">CleanupTime(<span class="hljs-params">triggerContext</span>.<span class="hljs-params">window</span>, <span class="hljs-params">timer</span>.<span class="hljs-params">getTimestamp</span>()</span>)) &#123;        clear<span class="hljs-constructor">AllState(<span class="hljs-params">triggerContext</span>.<span class="hljs-params">window</span>, <span class="hljs-params">evictingWindowState</span>, <span class="hljs-params">mergingWindows</span>)</span>;    &#125;&#125;</code></pre><p>只是对原文章进行了一下记录和补充，原文章出处:<a href="https://mp.weixin.qq.com/s/xZTGeFaaVW4VDDVgp3jwqg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/xZTGeFaaVW4VDDVgp3jwqg</a></p>]]></content>
    
    
    <categories>
      
      <category>Flink</category>
      
    </categories>
    
    
    <tags>
      
      <tag>window</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>经典垃圾收集器</title>
    <link href="/2020/05/22/%E7%BB%8F%E5%85%B8%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <url>/2020/05/22/%E7%BB%8F%E5%85%B8%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>垃圾收集算法是内存回收的方法理论，垃圾收集器是内存回收的执行者。各款经典垃圾收集器之间的关系如下(图中虚线的关系在JDK9之后已经不再存在)，如果垃圾收集器之间存在连线，就说明他们可以搭配使用。</p><p><img src="%E7%BB%8F%E5%85%B8%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png" srcset="/img/loading.gif" alt="alt"></p><h2 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h2><p>最基础，最历史悠久的收集器。单线程工作，单线程工作的意义并不是说明它只会使用一个处理器或一个收集线程去完成垃圾收集工作，强调的是它在进行垃圾收集时必须暂停其它所有工作的线程(STW)，直到它收集结束。Serial垃圾收集器简单高效，对于资源受限的的环境，它是所有垃圾收集器里额外内存消耗最小的。对于单核处理器或者核心较少的处理器来说，Serial收集器由于没有线程交互的开销，专心垃圾收集自然可以获得较高的垃圾收集效率。</p><h2 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h2><p>Serial垃圾收集器的多线程并行版本，除了同时使用多条线程进行垃圾回收之外，其余的行为包括Serial收集器可用的控制参数、收集算法、Stop The World、对象分配规则、回收策略都与Serial收集器完全一致。CMS垃圾收集器的出现巩固了ParNew收集器的地位，JDK5时，HotSpot推出了一款强交互中具有跨时代意义的收集器-CMS垃圾收集器，它首次实现了让垃圾线程和用户线程(基本上)同时工作，遗憾的是它不能与JDK1.4.0中就已经存在的垃圾收集器Parallel Scavenge配合工作，只能与Serial或者ParNew中的一个合作，ParNew是激活CMS收集器时，默认的新生代收集器。</p><p>G1垃圾收集器的出现代替了CMS。G1时一个面向全堆的垃圾收集器。从JDK 9开始，ParNew和CMS组合已经不再是官方推荐的服务端模式下的收集器方式了，官方希望它被G1代替，甚至还取消了ParNew和Serial Old以及Serial和CMS的组合，这意味着ParNew只能和CMS互相搭配使用。</p><h2 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h2><p>和ParNew一样基于标记-复制算法实现，也能并行收集垃圾不同点是CMS等收集器关注点是尽可能的缩短垃圾收集时用户等待的时间，而Parallel Scavenge收集器是为了达到一个可控的吞吐量(处理器用于用户代码时间和处理器消耗总时间的比值)，主要适合在后台运算不需要太多交互的分析性任务。</p><p> Parallel Scavenge提供了两个参数用于精确控制吞吐量,分别是控制最大垃圾收集停顿时间的 -XX:MaxGCPauseMillis参数以及设置吞吐量的-XX:GCTimeRatio参数。</p><p> -XX:MaxGCPauseMillis允许设置的值是一个大于0的毫秒数，收集器尽量保证内存回收的时间不大于用户设置的值。这个值应该设置的合理而不是尽可能小，因为垃圾收集停顿时间缩短是以牺牲新生代空间和吞吐量为代价的，系统把新生代设置的小一些，收集300M垃圾肯定比收集500M快，但是原来10s收集一次，每次需要100ms，现在5ms收集一次，每次需要70ms，吞吐量自然就下来了。</p><p> -XX:GCTimeRatio的值因该是0-100之间的数，也就是垃圾收集时间占处理器总时间的比例。如果设置为19，那么允许的最大垃圾收集时间为总时间比例的1/(1+19)即5%，默认值为99。</p><p>  Parallel Scavenge还有一个参数-XX:+UseAdaptiveSizePolicy。这个参数使用后不需要人工指定新生代的大小(-Xmn)、Eden区和Survivor区的比例(-XX:SurvivorRatio)、晋升老年代对象大小(-XX:PretenureSizeThreshold)等细节参数了，虚拟机会根据当前系统运行情况收集性能监控信息，动态调整这些参数以获得最合适的停顿时间以及最大的吞吐量。只需要设置最大堆(-Xmx)然后使用-XX:MaxGCPauseMillis或者-XX:GCTimeRatio参数给虚拟机指定一个优化目标。</p><h2 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h2><p>  Serial Old收集器是Serial收集器的老年代版本，它也是一个单线程的垃圾收集器，使用标记-整理算法。</p><h2 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h2><p>  Parallel Old是 Parallel Scavenge的老年代版本，支持多线程并发收集，基于标记-整理算法实现。这个收集器出现后，”吞吐量优先收集器“Parallel Scavenge收集器终于有了名副其实的老年代搭配使用组合。</p><h2 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h2><p>  CMS收集器是一种以获取最短的停顿时间为目标的收集器。目前很大一部分的Java应用是基于B/S架构开发的，这类应用关注服务的响应速度。CMS很符合这类应用的需求。</p><p>  CMS是基于标记-清除的算法实现的，整个过程可以划分为以下4个部分:</p><ul><li><p>初始标记</p></li><li><p>并发标记</p></li><li><p>重新标记</p></li><li><p>并发清除</p><p>其中初始标记和重新标记需要Stop The World。初始标记仅仅只是标记以下和GC Roots能直接关联的对象，速度非常快；并发标记就是从GC Roots能关联到的对象开是遍历整个对象图的过程，这个过程需要的时间比较长但是可以和用户线程并发执行；重新标记为了修正并发标记期间因用户线程继续执行导致的标记产生变动的那一部分；并发清除，清理删除掉标记阶段判断已经死亡的对象，由于不需要移动存活对象，所以这个阶段可以和用户线程并发。</p><p>CMS收集器缺点:</p></li><li><p>对处理器资源敏感。CMS默认启动回收线程数是(Cpu核心数量+3)/4,如果核心数量大于4个垃圾收集器占用不超过25%的处理器资源，但是当核心数不足四个时，CMS对用户程序的影响就很大。</p></li><li><p>CMS无法收集浮动垃圾，有可能出现”Concurrent Mode Failure”失败而导致另外一次”Stop The World”的Full GC产生。在CMS收集器的并发标记和并发清除阶段，用户线程还在运行，程序自然还会伴随着新的垃圾的产生，但是这部分垃圾对象出现在垃圾标记之后，只好留到下一次清理，这些垃圾称为”浮动垃圾”。由于在垃圾收集阶段用户线程还在运行，需要预留足够的空间给程序运行，在JDK 5的默认值设置下，当老年代内存使用超过了68%就会触发CMS垃圾收集器的收集，到JDK 6时被调高到了92%。如果CMS收集器运行期间没有预留够足够的内存空间给用户线程运行，就会出现一次”并发失败”，临时启用Serial Old收集器来重新回收老年代垃圾。<br>所以-XX: CMSInitiatingOccupancyFraction设置的太高容易导致大量的并发失败，星能反而会降低。</p></li></ul><ul><li><p>CMS时基于标记-清除算法实现的收集器，老年代会有大量空间碎片产生，有时不得不提前触发Full GC。为解决这个问题，CMS提供了一个-XX:+UseCMSCompactAtFullCollection开关用于在CMS不得不进行Full GC时开启内存碎片的合并整理过程，这个过程必须要移动存活对象，所以是无法和用户线程并发的，这会使用户线程停顿时间变长，CMS提供了另外一个参数-XX：CMSFullGCsBEforeCompaction，这个参数要求CMS在只想过若干次不整理空间的Full GC后，下一次Full GC前会先整理碎片空间。</p><h2 id="Garbage-First"><a href="#Garbage-First" class="headerlink" title="Garbage First"></a>Garbage First</h2><p>开创了垃圾收集器面向局部收集设计思路和基于Region的内存布局形式的先河。G1是一个面向服务端应用的收集器，它的开发是为了代替CMS收集器。在G1收集器出现之前的所有收集器，垃圾收集时要么收集整个新生代，要么就是整个老年代，再者就是整个对内存。G1可以面向堆内存任何部分形成会收集。</p><p>虽然G1也是基于分代理论设计的垃圾收集器但是它的堆内存布局和其它垃圾收集器有非常明显的差异:G1不再坚持固定大小、固定数量的分代区域划分，而是把Java堆划分成为多块大小相同的Region，每个Region都可以根据需要扮演Eden，Survivor或者老年代空间的角色，收集器能对扮演不同角色的空间采用不同的策略区处理。</p><p>Region中还有一块特殊的Humongous区域专门用来存储大对象，G1的大多数行为都会把Humongous Region作为老年代来看待。</p><p>G1收集垃圾之前可以建立可预测的停顿时间模型，因为它将Region当作单次回收的最小单位，这样可以有效的避免再整个Java堆进行全区域的回收。G1收集器区追踪每个Region区域垃圾堆积价值的大小，价值即回收得到的空间和所需要的时间，然后在后台维护一个优先级列表每次根据瀛湖所允许的收集停顿时间（-XX:MaxGCPauseMillis,默认200ms）优先回收价值高的那些Region，这也就是Garbage First名字的由来。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>垃圾回收算法</title>
    <link href="/2020/05/22/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"/>
    <url>/2020/05/22/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>垃圾收集器需要完成的事情:</p><ul><li>哪些内存需要回收</li><li>什么时间回收</li><li>怎么回收</li></ul><p>前面介绍了Java内存运行时区域的各个部分，其中程序计数器、虚拟机栈、本地方法栈三个区域随着线程线程而生，随着线程而灭，当线程结束时内存自然就跟着回收了，这几个区域不需要过多的考虑如何回收的问题。</p><p>Java堆和方法区这两个区域有着很显著的不确定性：一个接口的多个实现类需要的内存可能不一样，一个方法所执行的不同条件分支所需的内存也可能不一样，只有处于运行期间，我们才知道究竟会创建哪些对象，创建多少个对象，这部分内存的分配和回收是动态的。垃圾的回收也主要是针对这两个区域进行的。</p><h2 id="哪些内存需要回收"><a href="#哪些内存需要回收" class="headerlink" title="哪些内存需要回收"></a>哪些内存需要回收</h2><h3 id="如何确定对象已死"><a href="#如何确定对象已死" class="headerlink" title="如何确定对象已死"></a>如何确定对象已死</h3><ul><li><p>引用计数法: 给对象添加一个引用计数器，每当有一个对象引用它时，计数器就加一；当引用失效时，计数器值就减一；任何时刻计数器值为零的对象就不能再被使用。引用计数法原理简单，判定效率高，但必须配合大量的额外处理才能保证正确的工作。例如引用计数法很难解决循环应用的问题。</p></li><li><p>可达性分析法: 当前主流的商用程序语言的内存管理子系统都是通过可达性分析法来判定对象是否存活的。这个算法的基本思路是用过一系列称为”GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程走过的路程称为”引用链，如果某个对象到GC Roots间没有任何引用链，或者用图来说就是从GC Roots到这个对象不可达，则这个对象是不可能再被使用的。</p></li></ul><p>在Java中，固定可作为GC Roots的对象包括以下几种</p><ul><li><p>在虚拟机栈中引用的对象，例如各个线程被调的方法堆栈中使用到的参数、局部变量、临时变量等。</p></li><li><p>在方法区中静态属性引用的对象，例如Java类的引用类型静态变量。</p></li><li><p>在方法区中常量引用的对象，例如字符串常量池中的引用。</p></li><li><p>本地方法栈JNI引用的对象。</p></li><li><p>Java虚拟机内部的引用，例如基本数据类型对应的Class对象、一些常驻异常对象(NullPointException、OutOfMemoryError)、类加载器。</p></li><li><p>所有被同步锁(synchronized)持有的对象</p></li><li><p>反映Java虚拟机内部情况的JMXBean、JVMTI中注册回调、本地代码缓存等。</p></li></ul><p>除了这些固定的GC Roots外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象”临时性的加入”，共同构建GC Roots集合。在Java堆中某个区域的对象可能被其它区域的对象引用，这样在可达性分析时就需要将被引用区域的对象也加入到GC Roots中才能保证分析的正确性。</p><h3 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h3><p>无论是通过引用计数法判断对象的引用数量还是通过可达性分析法判断是否引用链可达，判断对象是否存活都和引用离不开关系。在JDK1.2之前，Java里的引用就是很传统的定义。如果reference类型的数据存储的数值代表的是另外一块内存的起始地址，就称该reference数据代表某块内存、某个对象的引用，一个对象在这种定义下只有”被引用”或者”未被引用”两种状态。<br>在JDK1.2之后对引用概念进行了扩展，将引用分为强引用、软引用、弱引用、虚引用4种。</p><ul><li><p>强引用: 最传统的引用定义。程序代码中普遍存在的引用赋值，类似 “Object obj = new Object()”。只要强引用存在，垃圾回收器就不会回收被引用的对象。</p></li><li><p>软引用: 还有用，非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出之前。会把这些对象列进行回收范围内的二次回收，如果这次回收还没有足够内存，才会抛出内存溢出异常。</p></li><li><p>弱引用: 非必须的对象，强度比软引用弱一些，弱引用关联的对象只能生存到下一次垃圾回收前。</p></li><li><p>虚引用: 完全不会对对象的生存时间构成影响，存在的目的只是为了在对象被垃圾收集器回收时收到一个系统通知。</p></li></ul><h3 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h3><p>即使在可达性分析算判定为不可达的对象，也不是”非死不可”,真正要宣告一个对象死亡，至少要经历两次标记过程。如果对象在可达性分析后没有与GC Roots相连的引用链，他将会被第一次标记，随后会进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。假如对象没有覆盖finalize(),或者finalize()方法液晶被虚拟机调用过，name虚拟机将这两种情况视为没有必要执行了。</p><p>如果有必要执行finalize()方法，那么该对象会被放置在一个F-Quueue中，稍后由一条虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize()方法,但并不一定承诺会等待它运行结束，因为如果一个对象的finalize()方法执行缓慢或者发生了死循环，可能使F-Queue中的其它对象永久处于等待。finalize()方法时对象最后一次逃脱死亡的机会，只要它与引用链上的任何一个对象建立起引用关系就不会被回收。</p><pre><code class="hljs processing"><span class="hljs-keyword">public</span> class FinalizeEscapeGC &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> FinalizeEscapeGC <span class="hljs-built_in">save</span> = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> isAlive()&#123;        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"hello i am still alive..."</span>);    &#125;    @Override    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> finalize() <span class="hljs-keyword">throws</span> Throwable &#123;        <span class="hljs-keyword">super</span>.finalize();        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"finalize..."</span>);        <span class="hljs-built_in">save</span> = <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span>[] args) <span class="hljs-keyword">throws</span> InterruptedException &#123;        FinalizeEscapeGC finalizeEscapeGC = <span class="hljs-keyword">new</span> FinalizeEscapeGC();        finalizeEscapeGC = <span class="hljs-keyword">null</span>;        System.gc();        <span class="hljs-comment">//Finalizer的优先级很低，等他一会</span>        Thread.sleep(<span class="hljs-number">500</span>);        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">save</span> != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-built_in">save</span>.isAlive();        &#125;<span class="hljs-keyword">else</span> &#123;            System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"I am dead..."</span>);        &#125;        <span class="hljs-built_in">save</span> = <span class="hljs-keyword">null</span>;        System.gc();        Thread.sleep(<span class="hljs-number">500</span>);        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">save</span> != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-built_in">save</span>.isAlive();        &#125;<span class="hljs-keyword">else</span> &#123;            System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"I am dead..."</span>);        &#125;    &#125;&#125;</code></pre><p>运行结果:</p><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">finalize</span></span>...<span class="hljs-function"><span class="hljs-title">hello</span></span> i am still alive...<span class="hljs-function"><span class="hljs-title">I</span></span> am dead...</code></pre><p>在垃圾收集器第一次回收finalizeEscapeGC对象时它通过finalize()方法与引用链中的静态属性引用的对象建立起了连接成功的进行了自救，第二段代码时它依然想故技重施但一个对象的finalize()方法只能执行一次所以第二次自救失败了。</p><p>finalize()方法运行代价高，不确定性打，无法保证各个对象的调用顺序，如今已经被官方明确声明为不推荐使用的语法，建议大家忘了这个语法。</p><h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><p>《Java虚拟机规范》中提到可以允许虚拟机不实现方法区的垃圾收集，因为方法区的垃圾收集的性价比通常是很低的，在Java堆中，尤其是新生代，对常规应用进行一次垃圾收集可以回收70%-90%的内存空间。相比之下，方法区回收囿于严格的回收条件，其区域的回收成果往往会比较低，方法区主要回收废弃的常量和不再使用的类型。<br>常量的回收: 比如说字符串常量池中有个常量”java”,在系统中没有任何一个字符串的值是”java”,且虚拟机中没有任何一个地方引用这个字面量，这个常量才会被回收。<br>类型卸载: 判断一个类型是否属于”不在使用的类”需要同时满足下面三个条件:</p><ul><li>该类的所有实例已经被回收</li><li>该类的类加载器已经被回收</li><li>该类对应的java.lang.class对象没有在任何地方被引用，无法再任何地方通过反射访问该类的方法</li></ul><p>Java虚拟机允许对满足上述三个条件的无用类进行回收，仅仅是”允许”，并不是必然。是否要进行回收HoSpot提供了 -Xnoclassgc参数进行控制。在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的压力。</p><h2 id="怎么回收"><a href="#怎么回收" class="headerlink" title="怎么回收"></a>怎么回收</h2><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><h4 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h4><p>分代收集建立在两个假说之上:</p><ul><li><p>弱分代假说: 绝大多数对象是朝生夕灭的</p></li><li><p>强分代假说: 熬过越多次垃圾收集的过程的对象就越难以消亡</p></li></ul><p>这两个分代假说共同奠定了多款常用的垃圾收集器的一致性原则: 收集器应该将Java堆划分出不同区域，然后将回收对象依据其年龄分配到不同的区域中存储。如果一个区域中大多数对象都是朝生夕灭的，难以熬过垃圾收集过程的话，那么把他们集中放到一起，每次回收时只用关注如何保留少量存活的对象而不是去标记那些大量需要被回收的对象，就能以较低的代价回收大量的空间；如果剩下的是难以消亡的对象，那把他们集中到一起，虚拟机便可以以较低的频率来回收这个区域，这样同时兼顾了垃圾收集的时间和内存空间的有效利用率。</p><p>把分代收集理论具体放到现在用的Java虚拟机里，设计者至少要把Java堆分为新生代和老年代。新生代每次垃圾收集有大量的对象死去，而每次回收后存的少量对象将会逐步晋升到老年代。假如现在要对新生代进行垃圾收集，但新生代的对象完全有可能被老年代的我对象引用的，为了找出这些对象，不得不在固定的GC Roots之外，再额外遍历整个老年代的所有对象来保证可达性分析结果的正确性。反过来也是一样。遍历整个老年代所有对象的方案虽然理论上可行，但是会为垃圾回收带来很多的负担。为了解决这个问题需要对分代收集理论添加第三条经验法则:</p><ul><li>跨代引用假说: 跨代引用相对于同代引用仅占极少数。</li></ul><p>这其实是由前两个假说逻辑推理得到的结论:存在引用关系的两个对象，是应该倾向于同时生存或者同时消亡的。依据这条假说，我们就不应该再为了少量的跨代引用去扫描整个老年代，也不必浪费空间纪录每一个对象是否存在或者存在哪些跨代引用，只需要在新生代上建立一个全局的数据结构(这个结构被称为”记忆集”)，这个结构把老年代分为若干小块，标识出老年代的哪些区域存在跨代引用。此后发生MinorGC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots中进行扫描。虽然这种方法需要在对象的引用关系改变后维护记录的正确性，会增加运行时的开销，相比于垃圾收集时扫描整个老年代仍然是划算的。</p><h4 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h4><p>和他的名字一样，算法分为”标记”和”清除”两个部分:首先标记出需要回收的对象，在标记完成后，统一回收这些对象。也可以反过来，标记存活的对象，统一回收未被标记的对象。它主要有两个缺点:</p><ul><li><p>执行效率不稳定。如果Java堆中包含大量要回收的对象，这时必须进行大量的标记和清除的动作，导致标记和清除两个过程的执行效率随着对象数量的增长而降低。所以标记清除算法常见于老年代回收。</p></li><li><p>碎片化问题: 标记清除后会产生大量不连续的内存碎片，可能会导致下次分配较大对象时无法找到足够的连续内存而不得不触发另一次垃圾回收的动作。</p></li></ul><h4 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h4><p>他将内存划分成为大小相等的两份，每次只使用其中的一块。当一块的内存用完了，就将还存活的对象复制到另外一块内存上，然后把自己使用的内存一次性清理掉，如果一块内存中由大量的对象存活，这个算法会存在大量的内存复制开销。这种算法不需要考虑空间碎片化的问题但是可用内存变成了之前的一半。</p><p>现在大多数虚拟机都采用了这种算法去回收新生代内存，IBM公司曾有一项专门研究对新生代”朝生夕灭”的特点做了更量化的诠释-新生代中的对象有98%熬不过第一次垃圾收集。因此没有必要将内存按1:1的比例划分。1989年 Andrew Appel提出了一种更优化的半区复制分代策略，现在称为”Appel式回收”。Appel式回收把新生代或分为一块较大的Eden区和两块较小的Survivor空间，每次分配内存只使用Eden区域和其中的一块Survivor。发生垃圾收集时将Eden区和Survivor中存活的对象复制到另外一块Survivor上，然后直接清理Eden和Survivor的空间。Eden和Survivor区域的大小比例是8:1。98%的的对象被回收只是”普通场景”，任何人都不能保证每次回收都只有不超过10%的对象存活。因此Appel式回收还有一个充当特殊情况的”逃生门”计划的安全设计，当Survivor空间不足以容纳一次MinorGC之后的存活的对象时，这些对象便将通过担保机制直接进入老年代。缺点:</p><ul><li><p>很多对象存活时要进行较多的复制操作，效率会降低</p></li><li><p>需要额外的担保空间进行分配担保</p></li></ul><h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>针对老年代对象存亡的特征，1974年Edward Lueders提出了”标记-整理”算法，其标记过程与”标记-清除”算法一样，但后续操作不是直接堆可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界外的内存。</p><p>移动存活对象，尤其是在老年代这种每次回收都有大量对象存活的区域，移动对象并更新所有引用这些对象的地方时一种极其负重的行为，移动对象这种操作必须全部暂停用户的应用才能进行。如果不移动和整理存活对象对象，分散在堆内的存活对象导致的空间碎片化问题只能依赖更为复杂的内存分配器和内存访问器来控制。从垃圾收集的停顿时间来看，不移动对象停顿时间更短。但从整体的吞吐量(回收和分配内存总的时间)来看，移动对象会更划算，因为内存分配比回收频繁的多。</p><h3 id="HotSpot垃圾回收算法细节"><a href="#HotSpot垃圾回收算法细节" class="headerlink" title="HotSpot垃圾回收算法细节"></a>HotSpot垃圾回收算法细节</h3><h4 id="根节点枚举"><a href="#根节点枚举" class="headerlink" title="根节点枚举"></a>根节点枚举</h4><p>所有垃圾收集器在根节点枚举这里都是要暂停用户线程的，现在可达性分析算法耗时最长的查找引用链的过程已经可以做到和用户线程并发，但根节点枚举还是必须在一个能保障一致性的快照中才能进行。如果在可达性分析的过程中，根节点的引用还在不断发生变化，分析结果就无法保证。</p><p>当前主流的Java虚拟机使用的都是准确式垃圾回收，当线程停顿下来之后，并不需要一个不漏的检查所有执行上下文和全局的引用位置，虚拟机有办法直接得到哪些地方存放着引用。HotSpot中使用OopMap的数据结构来达到这个目的。一旦类加载完成之后，HotSpot就会把对象内什么偏移量上时什么引用类型的数据计算出来，也会在特定的位置基类库下栈和寄存器里哪些位置时引用，并不需要直接从GC Roots查找。</p><h4 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h4><p>在OopMap的帮助下，HotSpot可以快速完成根节点枚举，但有一个问题就是引用关系发生变化，或者说导致OopMap变化的指令很多。为了解决这个问题有了安全点的设定，决定了用户程序在执行时并非在代码指令流的任何位置都能停顿下来回收垃圾，而是强制要求必须达到安全点才能暂停。安全点的选用不能太少以至于让垃圾收集器等待太多时间，也不能太过频繁以至于增大运行时内存压力。安全点的选用基本上是以”是否具有让程序长时间执行的特征”为标准选定的，因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长而长时间执行，”长时间执行”最明显的特征是指令序列的复用，如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生安全点。</p><p>如何在垃圾收集时让所有线程(不包括JNI线程)到达安全点？</p><ul><li><p>抢先式中断:垃圾收集时将所有线程中断，再去检查如果有线程中断的地方不在安全点继续执行到安全点中断。</p></li><li><p>抢先式中断:不直接对线程操作，仅仅简单的设置一个标志位，各个线程执行过程中会不停的轮询这个标志位，一旦法西安中断标志位为真时就在距离自己最近的安全点中断挂起。 </p></li></ul><h4 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h4><p>在程序不执行，例如Sleep或者Blocked状态，这时程序线程无法响应虚拟机的中断请求，不能自己走到安全的地方挂起自己时要如何处理呢？程序不可能等到线程重新被激活在走到安全点，安全区域的引入解决了这个问题。安全区域能够确保在某一段代码中引用关系不会发生变化。当用户线程进入安全区域后首先标识自己进了安全区域，这时在虚拟机发起垃圾收集时就不会管安全区域的线程了。当线程要离开安全区域，它要检查虚拟机是否已经完成了根节点枚举，如果完成了线程就继续执行，没有的话需要一直等待，直到收到可以离开安全区域的信号为止。</p><h4 id="并发的可达性分析"><a href="#并发的可达性分析" class="headerlink" title="并发的可达性分析"></a>并发的可达性分析</h4><p>关于可达性分析的扫描过程，如果用户线程是冻结的，只有收集器在工作，那不会有任何问题。如果收集器和用户线程并发工作呢？收集器在进行可达性分析时用户线程在修改引用关系，这可能导致两种问题，一种是把原本消亡的对象误标记为存活，这可以容忍，下次再收集好了，如果把原本存活的对象标记成为以消亡，这个就很危险了。</p><p>在遍历对象图的过程中，把访问都的对象按照”是否访问过”这个条件标记成以下三种颜色：</p><ul><li><p>白色：表示对象尚未被垃圾回收器访问过。显然，在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。</p></li><li><p>黑色：表示对象已经被垃圾回收器访问过，且这个对象的所有引用都已经扫描过。黑色的对象代表已经扫描过，它是安全存活的，如果有其它的对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象。</p></li><li><p>灰色：表示对象已经被垃圾回收器访问过，但这个对象至少存在一个引用还没有被扫描过。</p></li></ul><p>初始状态:只有GC Roots时黑色的。引用时有向的，对象只有被黑色对象引用才能存活</p><p><img src="%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B01.png" srcset="/img/loading.gif" alt="alt"></p><p>扫描过程中，从灰色的节点像从黑向白推进，灰色是黑色和白色的分界线</p><p><img src="%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B02.png" srcset="/img/loading.gif" alt="alt"></p><p>扫描完成，黑色是存活的对象，白色为死亡的对象</p><p><img src="%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B03.png" srcset="/img/loading.gif" alt="alt"></p><p>如果用户线程在标记进行时修改了引用关系，正在扫描的灰色对象的一个引用被切断了，同时原来引用的对象又与扫描过的黑色对象建立了引用</p><p><img src="%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B04.png" srcset="/img/loading.gif" alt="alt"></p><p>切断后重新被黑色引用的对象是原引用链的一部分。由于黑色对象不会重新扫描，这将导致扫描结束后两个被黑色引用的对象仍是白色，这个对象就会消失，这就很危险。</p><p><img src="%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B05.png" srcset="/img/loading.gif" alt="alt"></p><p>当且仅当以下两个条件同时满足时会产生”对象消失”的问题:</p><ul><li><p>赋值器插入了一条或者多条从黑色对象到白色对象的引用</p></li><li><p>赋值器删除了全部从灰色对象到该白色对象的引用</p></li></ul><p>因此，我们要解决并发扫描的对象消失问题时只需破坏任何一个条件即可。因此有增量更新和原始快照两种方式。</p><p>增量更新破坏的是第一个条件，当黑色对象插入了新的指向白色对象的引用关系时，就将这个新插入的引用关系记录下来，等并发扫描结束后，再将这些记录过的引用关系中的黑色对象作为根，重新扫描一次。</p><p>原始快照破坏了第二个条件，当灰色对象要删除指向白色对象的引用时，就将这个要删除的引用记录下来，在并发扫描结束时，再将这些记录过的引用关系中的灰色对象作为根，重新扫描一次。可与i理解为无论引用关系删除与否，都会按照扫描的那一刻的对象图快照来进行搜索。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随笔</title>
    <link href="/2020/05/18/%E9%9A%8F%E7%AC%94/"/>
    <url>/2020/05/18/%E9%9A%8F%E7%AC%94/</url>
    
    <content type="html"><![CDATA[<p>曾经那个对生活中的一切毫不在乎的少年长大了，他正试着脱去孤傲的外衣，拥抱多彩的生活，认真对待身边的一切，成为一个温柔、阳光的人。</p><p>脑海中偶尔会浮现自己伤害过别人的记忆，每到这时就像鲁迅在《风筝》中对弟弟严格的懊悔一样，其实很多次都不是出自本意，但最终都是得到了不好的结果，我把这些归咎于自己表达能力的欠缺。</p>]]></content>
    
    
    <categories>
      
      <category>life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>杭州美食</title>
    <link href="/2020/05/18/%E6%9D%AD%E5%B7%9E%E7%BE%8E%E9%A3%9F/"/>
    <url>/2020/05/18/%E6%9D%AD%E5%B7%9E%E7%BE%8E%E9%A3%9F/</url>
    
    <content type="html"><![CDATA[<p>热爱生活，热爱食物。记录一下所在地杭州的美食。</p><hr><p><b>Home Thai</b></p><p>菜系: 东南亚菜</p><p>地点: 武林广场</p><p>菜品小而精致，味道和泰加和蓝象比起来有过之而无不及，店内装修清新、凉爽、舒适，服务一般，价格中等偏上，适合2-4人餐。店内座位多，上菜快，基本不用排队。</p><p>照片没怎么拍，盗图有点麻烦自己去大众上看吧^-^。</p><hr>]]></content>
    
    
    <categories>
      
      <category>life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>food</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OutOfMemoryError异常</title>
    <link href="/2020/05/16/OutOfMemoryError%E5%BC%82%E5%B8%B8/"/>
    <url>/2020/05/16/OutOfMemoryError%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<p>除了程序计数器外，虚拟机的其他几个运行时区域都可能发生OutOfMemoryError异常。</p><h2 id="Java堆溢出"><a href="#Java堆溢出" class="headerlink" title="Java堆溢出"></a>Java堆溢出</h2><p>Java堆用于存放对象的实例，只要我们不断的创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么随着对象的增加，总容量触及堆的最大容量限制后就会产生内存溢出异常。</p><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeapOOM</span> &#123;</span>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OOMObject</span>&#123;</span>&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;        List&lt;OOMObject&gt; <span class="hljs-built_in">list</span> = <span class="hljs-keyword">new</span> ArrayList&lt;OOMObject&gt;();        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;            <span class="hljs-built_in">list</span>.add(<span class="hljs-keyword">new</span> OOMObject());        &#125;    &#125;&#125;</code></pre><p>运行结果:</p><pre><code class="hljs css"><span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.OutOfMemoryError</span>: <span class="hljs-selector-tag">Java</span> <span class="hljs-selector-tag">heap</span> <span class="hljs-selector-tag">space</span><span class="hljs-selector-tag">Dumping</span> <span class="hljs-selector-tag">heap</span> <span class="hljs-selector-tag">to</span> <span class="hljs-selector-tag">java_pid9900</span><span class="hljs-selector-class">.hprof</span> ...<span class="hljs-selector-tag">Heap</span> <span class="hljs-selector-tag">dump</span> <span class="hljs-selector-tag">file</span> <span class="hljs-selector-tag">created</span> <span class="hljs-selector-attr">[28341908 bytes in 0.068 secs]</span><span class="hljs-selector-tag">Exception</span> <span class="hljs-selector-tag">in</span> <span class="hljs-selector-tag">thread</span> "<span class="hljs-selector-tag">main</span>" <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.OutOfMemoryError</span>: <span class="hljs-selector-tag">Java</span> <span class="hljs-selector-tag">heap</span> <span class="hljs-selector-tag">space</span><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.Arrays</span><span class="hljs-selector-class">.copyOf</span>(<span class="hljs-selector-tag">Arrays</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:3210)</span><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.Arrays</span><span class="hljs-selector-class">.copyOf</span>(<span class="hljs-selector-tag">Arrays</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:3181)</span><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.ArrayList</span><span class="hljs-selector-class">.grow</span>(<span class="hljs-selector-tag">ArrayList</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:265)</span><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.ArrayList</span><span class="hljs-selector-class">.ensureExplicitCapacity</span>(<span class="hljs-selector-tag">ArrayList</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:239)</span><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.ArrayList</span><span class="hljs-selector-class">.ensureCapacityInternal</span>(<span class="hljs-selector-tag">ArrayList</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:231)</span><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.ArrayList</span><span class="hljs-selector-class">.add</span>(<span class="hljs-selector-tag">ArrayList</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:462)</span><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.paulo</span><span class="hljs-selector-class">.jvmBase</span><span class="hljs-selector-class">.HeapOOM</span><span class="hljs-selector-class">.main</span>(<span class="hljs-selector-tag">HeapOOM</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:17)</span></code></pre><p>Java堆内存的OutOfMemoryError异常是实际应用过程中最常见的异常，常规的处理方法是通过内存映像分析工具对Dump出来的堆存储快照进行分析，首先分清楚到底是出现了内存泄漏还是内存溢出，导致OOM的对象是否是必要的。<br>如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链，找到泄漏对象是通过怎样的引用路径，与哪些GC Roots相关联，才导致垃圾回收器无法回收他们。如果不是内存泄漏再从代码上检查是否存在某些对象生命周期过长、持有状态时间过长、存储结构不合理等情况。</p><h2 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h2><p>HotSpot中不区分虚拟机栈和本地方法栈，因此对于HotSpot来说，-Xoss参数虽然存在但是没有任何效果栈容量只能通过-Xss参数来设定。栈的异常包括两部分。</p><ul><li>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverFlowError异常</li><li>如果虚拟机的栈可动态扩展，当扩展栈容量无法申请到足够的内存时会抛出OutOfMemoryError异常</li></ul><p>《Java虚拟机规范》明确规定允许Java虚拟机实现自行选择是否支持栈的动态扩展，而HotSpot虚拟机选择不支持栈动态扩展，所以除非在创建线程申请内存时就应无法获得足够内存而出现OutofMemoryError异常，否则再线程运行时时不会因为扩展而导致内存溢出的，只会因为栈容量无法容纳新的栈帧而导致StackOverFlowError异常。</p><pre><code class="hljs arduino"><span class="hljs-comment">/**</span><span class="hljs-comment"> * VM Args -Xss128k</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaVMStackSOF</span> &#123;</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> stackLen = <span class="hljs-number">1</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stackLeak</span><span class="hljs-params">()</span></span>&#123;        stackLen++;        stackLeak();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;        JavaVMStackSOF javaVMStackSOF = <span class="hljs-keyword">new</span> JavaVMStackSOF();        javaVMStackSOF.stackLeak();    &#125;&#125;</code></pre><p>执行结果:</p><pre><code class="hljs css"><span class="hljs-selector-tag">Exception</span> <span class="hljs-selector-tag">in</span> <span class="hljs-selector-tag">thread</span> "<span class="hljs-selector-tag">main</span>" <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.StackOverflowError</span><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.paulo</span><span class="hljs-selector-class">.jvmBase</span><span class="hljs-selector-class">.JavaVMStackSOF</span><span class="hljs-selector-class">.stackLeak</span>(<span class="hljs-selector-tag">JavaVMStackSOF</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:10)</span><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.paulo</span><span class="hljs-selector-class">.jvmBase</span><span class="hljs-selector-class">.JavaVMStackSOF</span><span class="hljs-selector-class">.stackLeak</span>(<span class="hljs-selector-tag">JavaVMStackSOF</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:11)</span><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.paulo</span><span class="hljs-selector-class">.jvmBase</span><span class="hljs-selector-class">.JavaVMStackSOF</span><span class="hljs-selector-class">.stackLeak</span>(<span class="hljs-selector-tag">JavaVMStackSOF</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:11)</span>...</code></pre><p>无论是由于栈帧太大还是虚拟机容量太小，当新的栈帧内存无法分配是，HotSpot虚拟机抛出的都是StackOverFlowError异常。可是如果在栈允许动态扩展的虚拟机上，相同代码的执行结果会不同，在Classic虚拟机中会产生OutOfMemoryError异常。如果测试时通过多线程测试，在HotSpot虚拟机上也会产生OutOfMemoryError异常。但是这样产生的内存溢出异常和栈空间是否足够不存在直接关系，主要取决于操作系统本身的内存使用状态。<br>原因是操作系统分配给每个进程的内存是有限的，32位Windows操作系统最大为2G，2G减去最大堆内存，在减去最大方法区，程序计数器，直接内存和虚拟机进程使用的内存，剩下的就由虚拟机栈和本地方法栈来分配了，如果每个线程分配到的栈内存越大，可以建立的线程数量越少。</p><pre><code class="hljs arduino"><span class="hljs-comment">/**</span><span class="hljs-comment"> * VM Options -Xss2M</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaVMStackOOM</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notStop</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;&#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;            <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-built_in">run</span>() &#123;                    notStop();                &#125;            &#125;).start();        &#125;    &#125;&#125;</code></pre><hr><p><font size=1>tips: 如果要运行上面的代码，记得要保存当前的工作，Java的线程创建时映射到操作系统内核线程上，无限制的创建线程会给操作系统带来很大压力</font></p><hr><p>程序最终会得到OutOfMemoryError的异常。</p><p>出现StackOverFlow时会有明确的错误可以分析。如果使用HotSpot虚拟机默认参数，栈深度再大多数情况下到达1000-2000时没问题的。如果是由于建立线程太多导致内存溢出，再不能减少线程的情况下只能通过减少最大堆和减少栈容量来换取更多的线程。</p><h2 id="方法区和运行时常量池溢出"><a href="#方法区和运行时常量池溢出" class="headerlink" title="方法区和运行时常量池溢出"></a>方法区和运行时常量池溢出</h2><p>HotSpot从Jdk7开始逐步”去永久代计划”，并且在JDK8中完全使用元空间来代替永久代。String::intern()是一个本地方法，它的作用是如果字符串常量池中已经包含一个等于此String的常量，则返回常量池中代表这个字符串的引用，否则会将String对象包含的字符串添加到常量池，并且返回此String对象的引用。在JDK6或者更早之前的HotSpot中，常量池在永久代中在JDK7或者更高的版本中将原本放在永久区的字符串常量池移到了堆内存中，这会引申出一些有意思的影响。</p><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConstPoolOOM</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;        <span class="hljs-keyword">String</span> str1 = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">"计算机"</span>).append(<span class="hljs-string">"软件"</span>).toString();        System.out.<span class="hljs-built_in">println</span>(str1.intern() == str1);        <span class="hljs-keyword">String</span> str2 = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">"ja"</span>).append(<span class="hljs-string">"va"</span>).toString();        System.out.<span class="hljs-built_in">println</span>(str2.intern() == str2);    &#125;&#125;</code></pre><p>上面的代码再JDK6以及之前的环境中运行会返回两个false，再JDK7及以上的环境中运行会返回一个true和一个false。再JDK6及以前的环境中intern()会把首次遇到的字符串实例复制到永久代的常量池中，返回的也是永久代的地址，而StringBuilder创建的对象再Java堆中，所以会返回false。</p><p>在JDK7及以上的环境中常量池已经移到了Java堆中，只需要在常量池中记录一下字符串首次出现的引用即可，因此str1比较返回的时true。而”java”这个字符串之前已经出现过，返回的时第一次出现的引用，所以str2比较的结果为false。</p><p>因为运行时常量池在JDK7后移到了Java堆中，可以通过-Xmx减少堆的大小来测试溢出。</p><pre><code class="hljs arduino"><span class="hljs-comment">/**</span><span class="hljs-comment"> * VM Options -Xmx1M</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConstPoolOOM</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;        List&lt;<span class="hljs-keyword">String</span>&gt; <span class="hljs-built_in">list</span> = <span class="hljs-keyword">new</span> ArrayList&lt;<span class="hljs-keyword">String</span>&gt;();        <span class="hljs-keyword">int</span> i= <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;            <span class="hljs-built_in">list</span>.add(<span class="hljs-keyword">String</span>.valueOf(i++).intern());        &#125;    &#125;&#125;</code></pre><p>运行结果:</p><pre><code class="hljs css"><span class="hljs-selector-tag">Exception</span> <span class="hljs-selector-tag">in</span> <span class="hljs-selector-tag">thread</span> "<span class="hljs-selector-tag">main</span>" <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.OutOfMemoryError</span>: <span class="hljs-selector-tag">Java</span> <span class="hljs-selector-tag">heap</span> <span class="hljs-selector-tag">space</span><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.Arrays</span><span class="hljs-selector-class">.copyOf</span>(<span class="hljs-selector-tag">Arrays</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:3210)</span><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.Arrays</span><span class="hljs-selector-class">.copyOf</span>(<span class="hljs-selector-tag">Arrays</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:3181)</span><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.ArrayList</span><span class="hljs-selector-class">.grow</span>(<span class="hljs-selector-tag">ArrayList</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:265)</span><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.ArrayList</span><span class="hljs-selector-class">.ensureExplicitCapacity</span>(<span class="hljs-selector-tag">ArrayList</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:239)</span><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.ArrayList</span><span class="hljs-selector-class">.ensureCapacityInternal</span>(<span class="hljs-selector-tag">ArrayList</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:231)</span><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.ArrayList</span><span class="hljs-selector-class">.add</span>(<span class="hljs-selector-tag">ArrayList</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:462)</span><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.paulo</span><span class="hljs-selector-class">.jvmBase</span><span class="hljs-selector-class">.ConstPoolOOM</span><span class="hljs-selector-class">.main</span>(<span class="hljs-selector-tag">ConstPoolOOM</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:15)</span></code></pre><p>我们再来看看方法区其它部分的内容，方法区主要存放已经加载的类型信息，如类名、访问修饰符、常量池、字段描述、字段方法等。对于这部分的测试，可以在运行时产生大量的类去填满。</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * VM Arg: -XX:PermSize=10M -XX:MaxPermSize=10M</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaMethodAreaOOM</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;            Enhancer enhancer = <span class="hljs-keyword">new</span> Enhancer();            enhancer.setSuperclass(OOMObject<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;            enhancer.setUseCache(<span class="hljs-keyword">false</span>);            enhancer.setCallback(<span class="hljs-keyword">new</span> MethodInterceptor() &#123;                <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object o, Method method, Object[] args, MethodProxy proxy)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;                    <span class="hljs-keyword">return</span> proxy.invokeSuper(o,args);                &#125;            &#125;);            enhancer.create();        &#125;    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OOMObject</span></span>&#123;&#125;&#125;</code></pre><p>类似这样的代码很可能出现在实际应用中，当前的很多主流框架如Spring对类进行增强时会使用CGLib这类字节码技术。很多运行在Java虚拟机上的动态语言(例如Groovy)通常都会创建新类型支撑语言的动态性，随着这类语言的流行，方法区也越来越容易溢出。</p><p>在JDK8以后，永久代便完全退出了历史舞台，元空间作为代替者登场。在默认设置下前面创建新的动态类型的测试用力很难在迫使虚拟机方法去产生异常了。</p><h2 id="本机直接内存溢出"><a href="#本机直接内存溢出" class="headerlink" title="本机直接内存溢出"></a>本机直接内存溢出</h2><p>直接内存的大小可以通过-XX:MaxDirectMemorySize参数来指定，如果不指定，默认与Java堆最大值(-Xmx)一致。由直接内存导致的内存溢出，一个明显的特征就是Heap Dump文件不会看见有什么明显的异常，如果发现Dump文件很小并且程序中使用了DirectByteMemory，可以考虑是直接内存溢出了。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java虚拟机对象</title>
    <link href="/2020/05/16/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1/"/>
    <url>/2020/05/16/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p>虚拟机创建对象包含以下几个部分:</p><ul><li>当Java虚拟机遇到一个New指令时首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，那必须先执行相应的类的加载。</li><li>接下来虚拟机将为新生对象分配内存。对象所需要的的内存大小在类加载完成后便可完全确定，为对象分配空间的任务实际上便等同于把一块确定大小的内存从Java堆中划分出来。假设Java堆中内存时绝对规整的，所有被使用的内存放到一边，空闲的内存放到另外一边，中间放着一个指针作为分解指示器，那分配内存就是把指针向空闲的空间方向挪动一段与对象大小相等的举例，这种分配方式叫做”指针碰撞”。如果Java堆中的内存不是工整的，已经使用和空闲的交错在一起，虚拟机必须维护一个表，记录哪些内存是可用的，在分配的时候从列表中飞找到一块足够大的空间划分给对象实例，并更新表上的记录，这种分配方式成为”空闲列表”。选择哪种分配方式是由Java堆是否规整决定的，而Java堆是否规整又由采用的垃圾回收器是否有空间压缩整理的能力决定。<br>处理如何划分可用空间之外还有一个需要考虑的问题:对象创建在虚拟机中是非常频繁的行为。及时仅仅司改一个指针所指的位置，在并发情况下也并不是线程安全的。解决这个问题有两种方案。一种是对分配存储空间的动作进行同步处理,实际上是采用CAS配上失败重试保证更新操作的原子性；另外一种是把内存分配的动作按照线程划分到不同的空间区域进行，即每个线程在Java堆中预先分配一小块内存，那个线程要分配内存就在哪个线程的本地缓冲区分配，只有本地缓冲区用完了，分配新的缓冲区时才需要同步锁定。</li><li>内存分配完成之后，虚拟机必须将分配到的内存空间都初始化为零值，保证对象的实例在Java代码中介意不赋初始值也可以使用。</li><li>接下来Java虚拟机还要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的Hash码(实际调用对象的hashCode()方法时才会计算)、对象的GC分代年龄信息。</li><li>最后会执行<init>()方法，按照程序员的意愿对对象进行初始化。</li></ul><h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>对象在堆中的存储布局可以划分为三个部分:对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)。</p><p>HotSpot虚拟机的对象头包括两类信息。第一类是运行时数据，如Hash码、GC分代年龄、所状态标志、线程持有的锁、线程偏移量ID、偏向时间戳等。这部分数据的长度在32和64位的机器上分别为32位和64位。对象头的另一部分是类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例，并不是所有的虚拟机实现都必须在对象数据上保留类型指针即查找对象的元数据并不一定要通过对象本身。</p><p>接下来实例数据部分整是对象真正存储的有效信息，即在程序代码中所定义的各种类型的字段内容。HotSpot虚拟机默认的分配顺序为longs/doubles、ints、shorts/chars、bytes/booleans、oops。相同宽度的字段总是被分配到一起，在满足这个条件的前提下，在父类中定义的变量会出现在自雷之前。</p><p>第三部分是对齐填充。造HotSpot中任何对象的大小都必须是8字节的整数倍，所以需要填充位。</p><h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>在《Java虚拟机规范》中止规定了reference类型是一个对象的引用，没有规定这个引用应该通过什么方式去定位、访问到堆中对象的具体位置。主流的访问方式有句柄和直接引用两种:</p><ul><li><p>句柄引用<br>Java堆中换分出一块内存来存放句柄池，reference中存放的是句柄的地址。句柄中包含了对象实例数据与数据类型具体的地址信息。使用句柄最大的好处就是对象呗移动时只需要改变句柄中实例数据指针，reference不需要修改。<br><img src="%E5%8F%A5%E6%9F%84%E6%96%B9%E5%BC%8F%E5%AE%9A%E4%BD%8D%E6%95%B0%E6%8D%AE.png" srcset="/img/loading.gif" alt="alt"></p></li><li><p>直接引用<br>使用直接引用需要考虑如何存放对象的类型信息，reference中存储的直接就是对象地址。使用直接引用最大的好处就是速度更快，他节省了一次指针定位的时间开销。<br><img src="%E7%9B%B4%E6%8E%A5%E5%BC%95%E7%94%A8%E6%B3%95.png" srcset="/img/loading.gif" alt="alt"></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java内存区域划分</title>
    <link href="/2020/05/16/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86/"/>
    <url>/2020/05/16/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p>Java程序执行时是交给JVM执行的，所以我们在谈论Java内存区域划分的时候实际上指的是JVM内存区域划分。在讨论JVM内存区域划分之前先来看一下Java程序的具体执行流程。</p><p><img src="Java%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" srcset="/img/loading.gif" alt="alt"></p><p>如上图所示，首先Java源代码文件(.Java)文件会被Java编译器编译成字节码文件(.Class), 然后由JVM中的类加载器加载各个类的字节码文件，加载完毕后交由Java执行引擎执行， JVM会用一些空间来存储执行期间所用到的数据， 这些空间被称为Runtime Data Area(运行时数据区)， 也就是我们常说的JVM内存。</p><p>Java虚拟机在执行JAVA程序的时候回把它所管理的内存划分成为若干个不同的数据区。这些区域有各自的用途，以及创建销毁时间。具体的划分如下:</p><p><img src="%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png" srcset="/img/loading.gif" alt="alt"></p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器是一块很小的内存空间，它可以看做是当前所执行的字节码的行号指示器。由于Java的多线程是通过线程间轮流切换、分配处理器执行时间的方式来实现的，在任意一个时刻一个处理器只能执行一个线程的指令，为了线程切换后能恢复到正确的执行位置，每一个线程都需要一个独立的程序计数器。<br>如果线程执行的是一个Java方法，计数器记录的是正在执行的虚拟字节码的指令地址；如果正在执行的是本地方法(Native),这个计数器为空。此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemory的区域。</p><h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><p>与程序计数器一样，Java虚拟机栈也是线程私有的，他的生命周期与线程相同。每个方法被执行的时候，Java虚拟机都会创建一个栈帧用于存储局部变量、操作数栈、动态连接、方法出口等信息。</p><p>局部变量表存放了编译期间可知的各种Java虚拟机基本数据类型、对象引用和returnAddress(指向一条字节码指令的地址)</p><p>这些数据类型在局部变量表中的存储空间以局部变量槽(Slot)来表示，其中64位的long和double类型的数据会占用两个Slot，其余的数据类型数据只会占用一个。局部变量表所需的内存空间在编译期间分配完成，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量表空间是确定的，在方法执行期间不会改变局部变量表的大小。</p><p>在《Java虚拟机规范》中规定了两类异常情况:如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverFlow异常；如果Java虚拟机栈容量可动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。</p><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈和虚拟机栈的作用是相似的，区别只是本地方法栈服务于本地(Native)方法。、</p><h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h2><p>Java堆是所有线程共享的一块区域，在虚拟机启动时创建。此区域的唯一目的就是存放Java对象实例。</p><p>Java堆是垃圾收集器管理的内存区域。由于现代垃圾回收器大部分是基于分代回收理论设计的，所以Java堆中经常会出现”新生代” “老年代” “永久代” “From Survivor空间” “TO Survivor空间”等名词。</p><p>所有线程共享的Java堆可以划分出多个线程私有的分配缓冲区，以提升对象分配的效率，Java堆细分的目的是为了更好的回收内存或者更快的分配内存，不会改变Java堆存储内容的共性。</p><p>现在主流Java虚拟机的堆内存都是可以扩展的，如果在Java堆中没有内存完成实例分配，并且堆也无法扩展时，Java将会抛出OutOfMemoryError异常。</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区和Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。垃圾收集器行为在这个区域很少出现。这块区域的内存回收主要是针对常量池的回收和类型卸载。</p><p>根据《Java虚拟机规范》规定，如果方法区无法满足新的内存分配需求时，将会抛出OutOfMemoryError异常。</p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行时常量池是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口描述等信息，还有一项常量池表，用于存放编译期间产生的各种字面量和符号引用，这部分内容在类加载后存放到运行时常量池中。</p><hr><p><font size= 1>tips: 符号引用可以是任何形式的字面量，只要能无歧义的定位到目标即可。在编译时Java类并不知道所引用类的地址，只能用符号引用代替，在JVM加载类的过程中会把符号引用替换成为直接引用</font></p><hr><p>并非只有预置入Class文件中常量池的内容才可以进入运行实时常量池，运行期间也可以将新的常量放入常量池中，用的比较多的是String类的intern()方法。</p><p>既然运行时常量池是方法区的一部分，自然也受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>直接内存不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。但是这一部分的内存也被频繁使用。</p><p>在JDK1.4中加入了NIO(New Input/Output)类，引入一种基于通道与缓冲区(Buffer)的IO方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。</p><p>本机直接内存的大小不会受到Java堆大小的限制，但是会受到本机总内存的限制，一般服务器管理者配置虚拟机参数时会根据实际需要去设置-Xmx等信息，但通常会忽略直接内存，从而导致动态扩展时出现OutOfMemoryError异常。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/04/20/hello-world/"/>
    <url>/2020/04/20/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
