<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>垃圾收集器</title>
    <link href="/2020/05/20/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <url>/2020/05/20/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>垃圾收集器需要完成的事情:</p><ul><li>哪些内存需要回收</li><li>什么时间回收</li><li>怎么回收</li></ul><p>前面介绍了Java内存运行时区域的各个部分，其中程序计数器、虚拟机栈、本地方法栈三个区域随着线程线程而生，随着线程而灭，当线程结束时内存自然就跟着回收了，这几个区域不需要过多的考虑如何回收的问题。</p><p>Java堆和方法区这两个区域有着很显著的不确定性：一个接口的多个实现类需要的内存可能不一样，一个方法所执行的不同条件分支所需的内存也可能不一样，只有处于运行期间，我们才知道究竟会创建哪些对象，创建多少个对象，这部分内存的分配和回收是动态的。垃圾的回收也主要是针对这两个区域进行的。</p><h2 id="如何确定对象已死"><a href="#如何确定对象已死" class="headerlink" title="如何确定对象已死"></a>如何确定对象已死</h2><ul><li><p>引用计数法: 给对象添加一个引用计数器，每当有一个对象引用它时，计数器就加一；当引用失效时，计数器值就减一；任何时刻计数器值为零的对象就不能再被使用。引用计数法原理简单，判定效率高，但必须配合大量的额外处理才能保证正确的工作。例如引用计数法很难解决循环应用的问题。</p></li><li><p>可达性分析法: 当前主流的商用程序语言的内存管理子系统都是通过可达性分析法来判定对象是否存活的。这个算法的基本思路是用过一系列称为”GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程走过的路程称为”引用链，如果某个对象到GC Roots间没有任何引用链，或者用图来说就是从GC Roots到这个对象不可达，则这个对象是不可能再被使用的。</p></li></ul><p>在Java中，固定可作为GC Roots的对象包括以下几种</p><ul><li><p>在虚拟机栈中引用的对象，例如各个线程被调的方法堆栈中使用到的参数、局部变量、临时变量等。</p></li><li><p>在方法区中静态属性引用的对象，例如Java类的引用类型静态变量。</p></li><li><p>在方法区中常量引用的对象，例如字符串常量池中的引用。</p></li><li><p>本地方法栈JNI引用的对象。</p></li><li><p>Java虚拟机内部的引用，例如基本数据类型对应的Class对象、一些常驻异常对象(NullPointException、OutOfMemoryError)、类加载器。</p></li><li><p>所有被同步锁(synchronized)持有的对象</p></li><li><p>反映Java虚拟机内部情况的JMXBean、JVMTI中注册回调、本地代码缓存等。</p></li></ul><p>除了这些固定的GC Roots外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象”临时性的加入”，共同构建GC Roots集合。在Java堆中某个区域的对象可能被其它区域的对象引用，这样在可达性分析时就需要将被引用区域的对象也加入到GC Roots中才能保证分析的正确性。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随笔</title>
    <link href="/2020/05/18/%E9%9A%8F%E7%AC%94/"/>
    <url>/2020/05/18/%E9%9A%8F%E7%AC%94/</url>
    
    <content type="html"><![CDATA[<p>曾经那个对生活中的一切毫不在乎的少年长大了，他正试着脱去孤傲的外衣，拥抱多彩的生活，认真对待身边的一切，成为一个温柔、阳光的人。</p>]]></content>
    
    
    <categories>
      
      <category>life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>杭州美食</title>
    <link href="/2020/05/18/%E6%9D%AD%E5%B7%9E%E7%BE%8E%E9%A3%9F/"/>
    <url>/2020/05/18/%E6%9D%AD%E5%B7%9E%E7%BE%8E%E9%A3%9F/</url>
    
    <content type="html"><![CDATA[<p>热爱生活，热爱食物。记录一下所在地杭州的美食。</p><hr><p><b>Home Thai</b></p><p>菜系: 东南亚菜</p><p>地点: 武林广场</p><p>菜品小而精致，味道和泰加和蓝象比起来有过之而无不及，店内装修清新、凉爽、舒适，服务一般，价格中等偏上，适合2-4人餐。店内座位多，上菜快，基本不用排队。</p><p>照片没怎么拍，盗图有点麻烦自己去大众上看吧^-^。</p><hr>]]></content>
    
    
    <categories>
      
      <category>life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>food</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OutOfMemoryError异常</title>
    <link href="/2020/05/16/OutOfMemoryError%E5%BC%82%E5%B8%B8/"/>
    <url>/2020/05/16/OutOfMemoryError%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<p>除了程序计数器外，虚拟机的其他几个运行时区域都可能发生OutOfMemoryError异常。</p><h2 id="Java堆溢出"><a href="#Java堆溢出" class="headerlink" title="Java堆溢出"></a>Java堆溢出</h2><p>Java堆用于存放对象的实例，只要我们不断的创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么随着对象的增加，总容量触及堆的最大容量限制后就会产生内存溢出异常。</p><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeapOOM</span> &#123;</span>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OOMObject</span>&#123;</span>&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;        List&lt;OOMObject&gt; <span class="hljs-built_in">list</span> = <span class="hljs-keyword">new</span> ArrayList&lt;OOMObject&gt;();        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;            <span class="hljs-built_in">list</span>.add(<span class="hljs-keyword">new</span> OOMObject());        &#125;    &#125;&#125;</code></pre><p>运行结果:</p><pre><code class="hljs css"><span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.OutOfMemoryError</span>: <span class="hljs-selector-tag">Java</span> <span class="hljs-selector-tag">heap</span> <span class="hljs-selector-tag">space</span><span class="hljs-selector-tag">Dumping</span> <span class="hljs-selector-tag">heap</span> <span class="hljs-selector-tag">to</span> <span class="hljs-selector-tag">java_pid9900</span><span class="hljs-selector-class">.hprof</span> ...<span class="hljs-selector-tag">Heap</span> <span class="hljs-selector-tag">dump</span> <span class="hljs-selector-tag">file</span> <span class="hljs-selector-tag">created</span> <span class="hljs-selector-attr">[28341908 bytes in 0.068 secs]</span><span class="hljs-selector-tag">Exception</span> <span class="hljs-selector-tag">in</span> <span class="hljs-selector-tag">thread</span> "<span class="hljs-selector-tag">main</span>" <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.OutOfMemoryError</span>: <span class="hljs-selector-tag">Java</span> <span class="hljs-selector-tag">heap</span> <span class="hljs-selector-tag">space</span><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.Arrays</span><span class="hljs-selector-class">.copyOf</span>(<span class="hljs-selector-tag">Arrays</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:3210)</span><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.Arrays</span><span class="hljs-selector-class">.copyOf</span>(<span class="hljs-selector-tag">Arrays</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:3181)</span><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.ArrayList</span><span class="hljs-selector-class">.grow</span>(<span class="hljs-selector-tag">ArrayList</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:265)</span><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.ArrayList</span><span class="hljs-selector-class">.ensureExplicitCapacity</span>(<span class="hljs-selector-tag">ArrayList</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:239)</span><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.ArrayList</span><span class="hljs-selector-class">.ensureCapacityInternal</span>(<span class="hljs-selector-tag">ArrayList</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:231)</span><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.ArrayList</span><span class="hljs-selector-class">.add</span>(<span class="hljs-selector-tag">ArrayList</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:462)</span><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.paulo</span><span class="hljs-selector-class">.jvmBase</span><span class="hljs-selector-class">.HeapOOM</span><span class="hljs-selector-class">.main</span>(<span class="hljs-selector-tag">HeapOOM</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:17)</span></code></pre><p>Java堆内存的OutOfMemoryError异常是实际应用过程中最常见的异常，常规的处理方法是通过内存映像分析工具对Dump出来的堆存储快照进行分析，首先分清楚到底是出现了内存泄漏还是内存溢出，导致OOM的对象是否是必要的。<br>如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链，找到泄漏对象是通过怎样的引用路径，与哪些GC Roots相关联，才导致垃圾回收器无法回收他们。如果不是内存泄漏再从代码上检查是否存在某些对象生命周期过长、持有状态时间过长、存储结构不合理等情况。</p><h2 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h2><p>HotSpot中不区分虚拟机栈和本地方法栈，因此对于HotSpot来说，-Xoss参数虽然存在但是没有任何效果栈容量只能通过-Xss参数来设定。栈的异常包括两部分。</p><ul><li>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverFlowError异常</li><li>如果虚拟机的栈可动态扩展，当扩展栈容量无法申请到足够的内存时会抛出OutOfMemoryError异常</li></ul><p>《Java虚拟机规范》明确规定允许Java虚拟机实现自行选择是否支持栈的动态扩展，而HotSpot虚拟机选择不支持栈动态扩展，所以除非在创建线程申请内存时就应无法获得足够内存而出现OutofMemoryError异常，否则再线程运行时时不会因为扩展而导致内存溢出的，只会因为栈容量无法容纳新的栈帧而导致StackOverFlowError异常。</p><pre><code class="hljs arduino"><span class="hljs-comment">/**</span><span class="hljs-comment"> * VM Args -Xss128k</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaVMStackSOF</span> &#123;</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> stackLen = <span class="hljs-number">1</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stackLeak</span><span class="hljs-params">()</span></span>&#123;        stackLen++;        stackLeak();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;        JavaVMStackSOF javaVMStackSOF = <span class="hljs-keyword">new</span> JavaVMStackSOF();        javaVMStackSOF.stackLeak();    &#125;&#125;</code></pre><p>执行结果:</p><pre><code class="hljs css"><span class="hljs-selector-tag">Exception</span> <span class="hljs-selector-tag">in</span> <span class="hljs-selector-tag">thread</span> "<span class="hljs-selector-tag">main</span>" <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.StackOverflowError</span><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.paulo</span><span class="hljs-selector-class">.jvmBase</span><span class="hljs-selector-class">.JavaVMStackSOF</span><span class="hljs-selector-class">.stackLeak</span>(<span class="hljs-selector-tag">JavaVMStackSOF</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:10)</span><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.paulo</span><span class="hljs-selector-class">.jvmBase</span><span class="hljs-selector-class">.JavaVMStackSOF</span><span class="hljs-selector-class">.stackLeak</span>(<span class="hljs-selector-tag">JavaVMStackSOF</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:11)</span><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.paulo</span><span class="hljs-selector-class">.jvmBase</span><span class="hljs-selector-class">.JavaVMStackSOF</span><span class="hljs-selector-class">.stackLeak</span>(<span class="hljs-selector-tag">JavaVMStackSOF</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:11)</span>...</code></pre><p>无论是由于栈帧太大还是虚拟机容量太小，当新的栈帧内存无法分配是，HotSpot虚拟机抛出的都是StackOverFlowError异常。可是如果在栈允许动态扩展的虚拟机上，相同代码的执行结果会不同，在Classic虚拟机中会产生OutOfMemoryError异常。如果测试时通过多线程测试，在HotSpot虚拟机上也会产生OutOfMemoryError异常。但是这样产生的内存溢出异常和栈空间是否足够不存在直接关系，主要取决于操作系统本身的内存使用状态。<br>原因是操作系统分配给每个进程的内存是有限的，32位Windows操作系统最大为2G，2G减去最大堆内存，在减去最大方法区，程序计数器，直接内存和虚拟机进程使用的内存，剩下的就由虚拟机栈和本地方法栈来分配了，如果每个线程分配到的栈内存越大，可以建立的线程数量越少。</p><pre><code class="hljs arduino"><span class="hljs-comment">/**</span><span class="hljs-comment"> * VM Options -Xss2M</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaVMStackOOM</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notStop</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;&#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;            <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-built_in">run</span>() &#123;                    notStop();                &#125;            &#125;).start();        &#125;    &#125;&#125;</code></pre><hr><p><font size=1>tips: 如果要运行上面的代码，记得要保存当前的工作，Java的线程创建时映射到操作系统内核线程上，无限制的创建线程会给操作系统带来很大压力</font></p><hr><p>程序最终会得到OutOfMemoryError的异常。</p><p>出现StackOverFlow时会有明确的错误可以分析。如果使用HotSpot虚拟机默认参数，栈深度再大多数情况下到达1000-2000时没问题的。如果是由于建立线程太多导致内存溢出，再不能减少线程的情况下只能通过减少最大堆和减少栈容量来换取更多的线程。</p><h2 id="方法区和运行时常量池溢出"><a href="#方法区和运行时常量池溢出" class="headerlink" title="方法区和运行时常量池溢出"></a>方法区和运行时常量池溢出</h2><p>HotSpot从Jdk7开始逐步”去永久代计划”，并且在JDK8中完全使用元空间来代替永久代。String::intern()是一个本地方法，它的作用是如果字符串常量池中已经包含一个等于此String的常量，则返回常量池中代表这个字符串的引用，否则会将String对象包含的字符串添加到常量池，并且返回此String对象的引用。在JDK6或者更早之前的HotSpot中，常量池在永久代中在JDK7或者更高的版本中将原本放在永久区的字符串常量池移到了堆内存中，这会引申出一些有意思的影响。</p><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConstPoolOOM</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;        <span class="hljs-keyword">String</span> str1 = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">"计算机"</span>).append(<span class="hljs-string">"软件"</span>).toString();        System.out.<span class="hljs-built_in">println</span>(str1.intern() == str1);        <span class="hljs-keyword">String</span> str2 = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">"ja"</span>).append(<span class="hljs-string">"va"</span>).toString();        System.out.<span class="hljs-built_in">println</span>(str2.intern() == str2);    &#125;&#125;</code></pre><p>上面的代码再JDK6以及之前的环境中运行会返回两个false，再JDK7及以上的环境中运行会返回一个true和一个false。再JDK6及以前的环境中intern()会把首次遇到的字符串实例复制到永久代的常量池中，返回的也是永久代的地址，而StringBuilder创建的对象再Java堆中，所以会返回false。</p><p>在JDK7及以上的环境中常量池已经移到了Java堆中，只需要在常量池中记录一下字符串首次出现的引用即可，因此str1比较返回的时true。而”java”这个字符串之前已经出现过，返回的时第一次出现的引用，所以str2比较的结果为false。</p><p>因为运行时常量池在JDK7后移到了Java堆中，可以通过-Xmx减少堆的大小来测试溢出。</p><pre><code class="hljs arduino"><span class="hljs-comment">/**</span><span class="hljs-comment"> * VM Options -Xmx1M</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConstPoolOOM</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;        List&lt;<span class="hljs-keyword">String</span>&gt; <span class="hljs-built_in">list</span> = <span class="hljs-keyword">new</span> ArrayList&lt;<span class="hljs-keyword">String</span>&gt;();        <span class="hljs-keyword">int</span> i= <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;            <span class="hljs-built_in">list</span>.add(<span class="hljs-keyword">String</span>.valueOf(i++).intern());        &#125;    &#125;&#125;</code></pre><p>运行结果:</p><pre><code class="hljs css"><span class="hljs-selector-tag">Exception</span> <span class="hljs-selector-tag">in</span> <span class="hljs-selector-tag">thread</span> "<span class="hljs-selector-tag">main</span>" <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.OutOfMemoryError</span>: <span class="hljs-selector-tag">Java</span> <span class="hljs-selector-tag">heap</span> <span class="hljs-selector-tag">space</span><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.Arrays</span><span class="hljs-selector-class">.copyOf</span>(<span class="hljs-selector-tag">Arrays</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:3210)</span><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.Arrays</span><span class="hljs-selector-class">.copyOf</span>(<span class="hljs-selector-tag">Arrays</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:3181)</span><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.ArrayList</span><span class="hljs-selector-class">.grow</span>(<span class="hljs-selector-tag">ArrayList</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:265)</span><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.ArrayList</span><span class="hljs-selector-class">.ensureExplicitCapacity</span>(<span class="hljs-selector-tag">ArrayList</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:239)</span><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.ArrayList</span><span class="hljs-selector-class">.ensureCapacityInternal</span>(<span class="hljs-selector-tag">ArrayList</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:231)</span><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.ArrayList</span><span class="hljs-selector-class">.add</span>(<span class="hljs-selector-tag">ArrayList</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:462)</span><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.paulo</span><span class="hljs-selector-class">.jvmBase</span><span class="hljs-selector-class">.ConstPoolOOM</span><span class="hljs-selector-class">.main</span>(<span class="hljs-selector-tag">ConstPoolOOM</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:15)</span></code></pre><p>我们再来看看方法区其它部分的内容，方法区主要存放已经加载的类型信息，如类名、访问修饰符、常量池、字段描述、字段方法等。对于这部分的测试，可以在运行时产生大量的类去填满。</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * VM Arg: -XX:PermSize=10M -XX:MaxPermSize=10M</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaMethodAreaOOM</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;            Enhancer enhancer = <span class="hljs-keyword">new</span> Enhancer();            enhancer.setSuperclass(OOMObject<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;            enhancer.setUseCache(<span class="hljs-keyword">false</span>);            enhancer.setCallback(<span class="hljs-keyword">new</span> MethodInterceptor() &#123;                <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object o, Method method, Object[] args, MethodProxy proxy)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;                    <span class="hljs-keyword">return</span> proxy.invokeSuper(o,args);                &#125;            &#125;);            enhancer.create();        &#125;    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OOMObject</span></span>&#123;&#125;&#125;</code></pre><p>类似这样的代码很可能出现在实际应用中，当前的很多主流框架如Spring对类进行增强时会使用CGLib这类字节码技术。很多运行在Java虚拟机上的动态语言(例如Groovy)通常都会创建新类型支撑语言的动态性，随着这类语言的流行，方法区也越来越容易溢出。</p><p>在JDK8以后，永久代便完全退出了历史舞台，元空间作为代替者登场。在默认设置下前面创建新的动态类型的测试用力很难在迫使虚拟机方法去产生异常了。</p><h2 id="本机直接内存溢出"><a href="#本机直接内存溢出" class="headerlink" title="本机直接内存溢出"></a>本机直接内存溢出</h2><p>直接内存的大小可以通过-XX:MaxDirectMemorySize参数来指定，如果不指定，默认与Java堆最大值(-Xmx)一致。由直接内存导致的内存溢出，一个明显的特征就是Heap Dump文件不会看见有什么明显的异常，如果发现Dump文件很小并且程序中使用了DirectByteMemory，可以考虑是直接内存溢出了。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java虚拟机对象</title>
    <link href="/2020/05/16/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1/"/>
    <url>/2020/05/16/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p>虚拟机创建对象包含以下几个部分:</p><ul><li>当Java虚拟机遇到一个New指令时首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，那必须先执行相应的类的加载。</li><li>接下来虚拟机将为新生对象分配内存。对象所需要的的内存大小在类加载完成后便可完全确定，为对象分配空间的任务实际上便等同于把一块确定大小的内存从Java堆中划分出来。假设Java堆中内存时绝对规整的，所有被使用的内存放到一边，空闲的内存放到另外一边，中间放着一个指针作为分解指示器，那分配内存就是把指针向空闲的空间方向挪动一段与对象大小相等的举例，这种分配方式叫做”指针碰撞”。如果Java堆中的内存不是工整的，已经使用和空闲的交错在一起，虚拟机必须维护一个表，记录哪些内存是可用的，在分配的时候从列表中飞找到一块足够大的空间划分给对象实例，并更新表上的记录，这种分配方式成为”空闲列表”。选择哪种分配方式是由Java堆是否规整决定的，而Java堆是否规整又由采用的垃圾回收器是否有空间压缩整理的能力决定。<br>处理如何划分可用空间之外还有一个需要考虑的问题:对象创建在虚拟机中是非常频繁的行为。及时仅仅司改一个指针所指的位置，在并发情况下也并不是线程安全的。解决这个问题有两种方案。一种是对分配存储空间的动作进行同步处理,实际上是采用CAS配上失败重试保证更新操作的原子性；另外一种是把内存分配的动作按照线程划分到不同的空间区域进行，即每个线程在Java堆中预先分配一小块内存，那个线程要分配内存就在哪个线程的本地缓冲区分配，只有本地缓冲区用完了，分配新的缓冲区时才需要同步锁定。</li><li>内存分配完成之后，虚拟机必须将分配到的内存空间都初始化为零值，保证对象的实例在Java代码中介意不赋初始值也可以使用。</li><li>接下来Java虚拟机还要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的Hash码(实际调用对象的hashCode()方法时才会计算)、对象的GC分代年龄信息。</li><li>最后会执行<init>()方法，按照程序员的意愿对对象进行初始化。</li></ul><h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>对象在堆中的存储布局可以划分为三个部分:对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)。</p><p>HotSpot虚拟机的对象头包括两类信息。第一类是运行时数据，如Hash码、GC分代年龄、所状态标志、线程持有的锁、线程偏移量ID、偏向时间戳等。这部分数据的长度在32和64位的机器上分别为32位和64位。对象头的另一部分是类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例，并不是所有的虚拟机实现都必须在对象数据上保留类型指针即查找对象的元数据并不一定要通过对象本身。</p><p>接下来实例数据部分整是对象真正存储的有效信息，即在程序代码中所定义的各种类型的字段内容。HotSpot虚拟机默认的分配顺序为longs/doubles、ints、shorts/chars、bytes/booleans、oops。相同宽度的字段总是被分配到一起，在满足这个条件的前提下，在父类中定义的变量会出现在自雷之前。</p><p>第三部分是对齐填充。造HotSpot中任何对象的大小都必须是8字节的整数倍，所以需要填充位。</p><h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>在《Java虚拟机规范》中止规定了reference类型是一个对象的引用，没有规定这个引用应该通过什么方式去定位、访问到堆中对象的具体位置。主流的访问方式有句柄和直接引用两种:</p><ul><li><p>句柄引用<br>Java堆中换分出一块内存来存放句柄池，reference中存放的是句柄的地址。句柄中包含了对象实例数据与数据类型具体的地址信息。使用句柄最大的好处就是对象呗移动时只需要改变句柄中实例数据指针，reference不需要修改。<br><img src="%E5%8F%A5%E6%9F%84%E6%96%B9%E5%BC%8F%E5%AE%9A%E4%BD%8D%E6%95%B0%E6%8D%AE.png" srcset="/img/loading.gif" alt="alt"></p></li><li><p>直接引用<br>使用直接引用需要考虑如何存放对象的类型信息，reference中存储的直接就是对象地址。使用直接引用最大的好处就是速度更快，他节省了一次指针定位的时间开销。<br><img src="%E7%9B%B4%E6%8E%A5%E5%BC%95%E7%94%A8%E6%B3%95.png" srcset="/img/loading.gif" alt="alt"></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java内存区域划分</title>
    <link href="/2020/05/16/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86/"/>
    <url>/2020/05/16/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p>Java程序执行时是交给JVM执行的，所以我们在谈论Java内存区域划分的时候实际上指的是JVM内存区域划分。在讨论JVM内存区域划分之前先来看一下Java程序的具体执行流程。</p><p><img src="Java%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" srcset="/img/loading.gif" alt="alt"></p><p>如上图所示，首先Java源代码文件(.Java)文件会被Java编译器编译成字节码文件(.Class), 然后由JVM中的类加载器加载各个类的字节码文件，加载完毕后交由Java执行引擎执行， JVM会用一些空间来存储执行期间所用到的数据， 这些空间被称为Runtime Data Area(运行时数据区)， 也就是我们常说的JVM内存。</p><p>Java虚拟机在执行JAVA程序的时候回把它所管理的内存划分成为若干个不同的数据区。这些区域有各自的用途，以及创建销毁时间。具体的划分如下:</p><p><img src="%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png" srcset="/img/loading.gif" alt="alt"></p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器是一块很小的内存空间，它可以看做是当前所执行的字节码的行号指示器。由于Java的多线程是通过线程间轮流切换、分配处理器执行时间的方式来实现的，在任意一个时刻一个处理器只能执行一个线程的指令，为了线程切换后能恢复到正确的执行位置，每一个线程都需要一个独立的程序计数器。<br>如果线程执行的是一个Java方法，计数器记录的是正在执行的虚拟字节码的指令地址；如果正在执行的是本地方法(Native),这个计数器为空。此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemory的区域。</p><h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><p>与程序计数器一样，Java虚拟机栈也是线程私有的，他的生命周期与线程相同。每个方法被执行的时候，Java虚拟机都会创建一个栈帧用于存储局部变量、操作数栈、动态连接、方法出口等信息。</p><p>局部变量表存放了编译期间可知的各种Java虚拟机基本数据类型、对象引用和returnAddress(指向一条字节码指令的地址)</p><p>这些数据类型在局部变量表中的存储空间以局部变量槽(Slot)来表示，其中64位的long和double类型的数据会占用两个Slot，其余的数据类型数据只会占用一个。局部变量表所需的内存空间在编译期间分配完成，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量表空间是确定的，在方法执行期间不会改变局部变量表的大小。</p><p>在《Java虚拟机规范》中规定了两类异常情况:如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverFlow异常；如果Java虚拟机栈容量可动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。</p><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈和虚拟机栈的作用是相似的，区别只是本地方法栈服务于本地(Native)方法。、</p><h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h2><p>Java堆是所有线程共享的一块区域，在虚拟机启动时创建。此区域的唯一目的就是存放Java对象实例。</p><p>Java堆是垃圾收集器管理的内存区域。由于现代垃圾回收器大部分是基于分代回收理论设计的，所以Java堆中经常会出现”新生代” “老年代” “永久代” “From Survivor空间” “TO Survivor空间”等名词。</p><p>所有线程共享的Java堆可以划分出多个线程私有的分配缓冲区，以提升对象分配的效率，Java堆细分的目的是为了更好的回收内存或者更快的分配内存，不会改变Java堆存储内容的共性。</p><p>现在主流Java虚拟机的堆内存都是可以扩展的，如果在Java堆中没有内存完成实例分配，并且堆也无法扩展时，Java将会抛出OutOfMemoryError异常。</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区和Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。垃圾收集器行为在这个区域很少出现。这块区域的内存回收主要是针对常量池的回收和类型卸载。</p><p>根据《Java虚拟机规范》规定，如果方法区无法满足新的内存分配需求时，将会抛出OutOfMemoryError异常。</p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行时常量池是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口描述等信息，还有一项常量池表，用于存放编译期间产生的各种字面量和符号引用，这部分内容在类加载后存放到运行时常量池中。</p><hr><p><font size= 1>tips: 符号引用可以是任何形式的字面量，只要能无歧义的定位到目标即可。在编译时Java类并不知道所引用类的地址，只能用符号引用代替，在JVM加载类的过程中会把符号引用替换成为直接引用</font></p><hr><p>并非只有预置入Class文件中常量池的内容才可以进入运行实时常量池，运行期间也可以将新的常量放入常量池中，用的比较多的是String类的intern()方法。</p><p>既然运行时常量池是方法区的一部分，自然也受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>直接内存不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。但是这一部分的内存也被频繁使用。</p><p>在JDK1.4中加入了NIO(New Input/Output)类，引入一种基于通道与缓冲区(Buffer)的IO方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。</p><p>本机直接内存的大小不会受到Java堆大小的限制，但是会受到本机总内存的限制，一般服务器管理者配置虚拟机参数时会根据实际需要去设置-Xmx等信息，但通常会忽略直接内存，从而导致动态扩展时出现OutOfMemoryError异常。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/04/20/hello-world/"/>
    <url>/2020/04/20/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
